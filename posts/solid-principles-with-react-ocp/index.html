<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID Principles With React - OCP | Hakka Blog</title><meta name=keywords content><meta name=description content="Hi 大家好我是 Curt 家人
系列相關文章 SOLID Principles With React SOLID Principles With React - SRP（單一職責原則） SOLID Principles With React - LSP（里氏替換原則） Interface segregation principle (ISP) - 介面隔離原則 Dependency inversion principle (DIP) - 依賴反轉原則 OCP SOLID 的第二個原則 OCP，中文又稱作開放封閉原則，意思是說
我允許我的 class、module、function 給你擴充，但不允許你修改它
定義上也是這麼說
software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification
我們先來釐清什麼是擴充、什麼是修改
擴充：在原本的功能上擴充一些東西，但別人想用原本的功能也不影響，是可以選擇的。 修改：將核心的邏輯、功能換掉，所有人都會用到同一個功能。 舉個生活中的例子， EX: 機車是用來交通的工具，如果有導航需求自己可以加裝手機架，給其他人騎的時候，如果他覺得不需要可以隨時拆掉，不影響原本的功用。
因此當有一個需求會影響這個 class 時，需要思考一下它是 擴充 還是 修改，
如果是擴充：那不應該修改這個檔案的 code，而是進行擴充 如果是修改：那就直接改檔案把。 我們來延續 SRP 中物件導向的例子"><meta name=author content><link rel=canonical href=https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-with-react-ocp/><link crossorigin=anonymous href=https://curt6815463.github.io/hakka-dev-blog/assets/css/stylesheet.min.3764877ba3a5494f5186c907876e4ed3f4d81cc8b5c752600f4d27d8cdfd1b45.css integrity="sha256-N2SHe6OlSU9RhskHh25O0/TYHMi1x1JgD00n2M39G0U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=https://curt6815463.github.io/hakka-dev-blog/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script> <link rel=icon href=https://curt6815463.github.io/hakka-dev-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://curt6815463.github.io/hakka-dev-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://curt6815463.github.io/hakka-dev-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://curt6815463.github.io/hakka-dev-blog/apple-touch-icon.png><link rel=mask-icon href=https://curt6815463.github.io/hakka-dev-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=https://curt6815463.github.io/hakka-dev-blog/css/custom.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="SOLID Principles With React - OCP"><meta property="og:description" content="Hi 大家好我是 Curt 家人
系列相關文章 SOLID Principles With React SOLID Principles With React - SRP（單一職責原則） SOLID Principles With React - LSP（里氏替換原則） Interface segregation principle (ISP) - 介面隔離原則 Dependency inversion principle (DIP) - 依賴反轉原則 OCP SOLID 的第二個原則 OCP，中文又稱作開放封閉原則，意思是說
我允許我的 class、module、function 給你擴充，但不允許你修改它
定義上也是這麼說
software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification
我們先來釐清什麼是擴充、什麼是修改
擴充：在原本的功能上擴充一些東西，但別人想用原本的功能也不影響，是可以選擇的。 修改：將核心的邏輯、功能換掉，所有人都會用到同一個功能。 舉個生活中的例子， EX: 機車是用來交通的工具，如果有導航需求自己可以加裝手機架，給其他人騎的時候，如果他覺得不需要可以隨時拆掉，不影響原本的功用。
因此當有一個需求會影響這個 class 時，需要思考一下它是 擴充 還是 修改，
如果是擴充：那不應該修改這個檔案的 code，而是進行擴充 如果是修改：那就直接改檔案把。 我們來延續 SRP 中物件導向的例子"><meta property="og:type" content="article"><meta property="og:url" content="https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-with-react-ocp/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-23T02:27:06+08:00"><meta property="article:modified_time" content="2022-06-23T02:27:06+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID Principles With React - OCP"><meta name=twitter:description content="Hi 大家好我是 Curt 家人
系列相關文章 SOLID Principles With React SOLID Principles With React - SRP（單一職責原則） SOLID Principles With React - LSP（里氏替換原則） Interface segregation principle (ISP) - 介面隔離原則 Dependency inversion principle (DIP) - 依賴反轉原則 OCP SOLID 的第二個原則 OCP，中文又稱作開放封閉原則，意思是說
我允許我的 class、module、function 給你擴充，但不允許你修改它
定義上也是這麼說
software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification
我們先來釐清什麼是擴充、什麼是修改
擴充：在原本的功能上擴充一些東西，但別人想用原本的功能也不影響，是可以選擇的。 修改：將核心的邏輯、功能換掉，所有人都會用到同一個功能。 舉個生活中的例子， EX: 機車是用來交通的工具，如果有導航需求自己可以加裝手機架，給其他人騎的時候，如果他覺得不需要可以隨時拆掉，不影響原本的功用。
因此當有一個需求會影響這個 class 時，需要思考一下它是 擴充 還是 修改，
如果是擴充：那不應該修改這個檔案的 code，而是進行擴充 如果是修改：那就直接改檔案把。 我們來延續 SRP 中物件導向的例子"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://curt6815463.github.io/hakka-dev-blog/posts/"},{"@type":"ListItem","position":2,"name":"SOLID Principles With React - OCP","item":"https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-with-react-ocp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID Principles With React - OCP","name":"SOLID Principles With React - OCP","description":"Hi 大家好我是 Curt 家人\n系列相關文章 SOLID Principles With React SOLID Principles With React - SRP（單一職責原則） SOLID Principles With React - LSP（里氏替換原則） Interface segregation principle (ISP) - 介面隔離原則 Dependency inversion principle (DIP) - 依賴反轉原則 OCP SOLID 的第二個原則 OCP，中文又稱作開放封閉原則，意思是說\n我允許我的 class、module、function 給你擴充，但不允許你修改它\n定義上也是這麼說\nsoftware entities (classes, modules, functions, etc.) should be open for extension, but closed for modification\n我們先來釐清什麼是擴充、什麼是修改\n擴充：在原本的功能上擴充一些東西，但別人想用原本的功能也不影響，是可以選擇的。 修改：將核心的邏輯、功能換掉，所有人都會用到同一個功能。 舉個生活中的例子， EX: 機車是用來交通的工具，如果有導航需求自己可以加裝手機架，給其他人騎的時候，如果他覺得不需要可以隨時拆掉，不影響原本的功用。\n因此當有一個需求會影響這個 class 時，需要思考一下它是 擴充 還是 修改，\n如果是擴充：那不應該修改這個檔案的 code，而是進行擴充 如果是修改：那就直接改檔案把。 我們來延續 SRP 中物件導向的例子","keywords":[],"articleBody":"Hi 大家好我是 Curt 家人\n系列相關文章 SOLID Principles With React SOLID Principles With React - SRP（單一職責原則） SOLID Principles With React - LSP（里氏替換原則） Interface segregation principle (ISP) - 介面隔離原則 Dependency inversion principle (DIP) - 依賴反轉原則 OCP SOLID 的第二個原則 OCP，中文又稱作開放封閉原則，意思是說\n我允許我的 class、module、function 給你擴充，但不允許你修改它\n定義上也是這麼說\nsoftware entities (classes, modules, functions, etc.) should be open for extension, but closed for modification\n我們先來釐清什麼是擴充、什麼是修改\n擴充：在原本的功能上擴充一些東西，但別人想用原本的功能也不影響，是可以選擇的。 修改：將核心的邏輯、功能換掉，所有人都會用到同一個功能。 舉個生活中的例子， EX: 機車是用來交通的工具，如果有導航需求自己可以加裝手機架，給其他人騎的時候，如果他覺得不需要可以隨時拆掉，不影響原本的功用。\n因此當有一個需求會影響這個 class 時，需要思考一下它是 擴充 還是 修改，\n如果是擴充：那不應該修改這個檔案的 code，而是進行擴充 如果是修改：那就直接改檔案把。 我們來延續 SRP 中物件導向的例子\nOCP 物件導向的範例 class SumStudentsGrades { constructor(students = []) { this.students = students; } sum() { return this.students.reduce((acc, student) =\u003e { return acc + student.grade; }, 0); } } const studentA = { name: \"小劉\", grade: 20 }; const studentB = { name: \"小紅\", grade: 30 }; const studentC = { name: \"小白\", grade: 40 }; const studens = [studentA, studentB, studentC]; const studentsGrades = new StudentsGrades(studens); studentsGrades.sum(); 前面有提到，全班成績的加總算法可能會更動，像是客家人身份要多 10 分，那我們思考一下這樣算是 擴充 還是 修改？\n答案是我覺得兩個都有可能，首先要問一下 user\n以後都固定這樣算嗎？ （修改） 還是要提供兩種算法，讓大家自由決定要拿原始的加總成績還是加權後的加總成績 （擴充） 假如最後確認的需求是擴充，但我卻直接修改 SumStudentsGrades 會變怎樣呢？我們來看看\nclass SumStudentsGrades { constructor(students = [], sumFormulaType) { this.students = students; this.sumFormulaType = sumFormulaType; } sum() { if (this.sumFormulaType === \"hakkaPlus10\") { return this.students.reduce((acc, student) =\u003e { const additionalScore = student.isHakka ? 10 : 0; return acc + student.grade + additionalScore; }, 0); } else { return this.students.reduce((acc, student) =\u003e { return acc + student.grade; }, 0); } } } 在使用 SumStudentsGrades 時，我們多傳入一個參數 hakkaPlus10，用它來決定我們的加總算法\n使用時變這樣\n//... const sumFormulaType = \"hakkaPlus10\"; const studentsGrades = new SumStudentsGrades(studens, sumFormulaType); // 最後結果: 100 studentsGrades.sum(); 看起來沒問題，不過以後想要擴充其他功能，EX: 原住民加 20 分，那我不就要增加一個 if 在 SumStudentsGrades？ 所以違反 OCP\n那可以怎麼改呢？ 首先將 sum 的邏輯 委派 給其他 class，原本的 class 只需要呼叫他的 function 就好\nclass SumStudentsGrades { constructor(students = [], sumGrades) { this.students = students; this.sumGrades = sumGrades; } sum() { return sumGrades.sum(this.students); } } 接著建立負責處理 sum 的 class：SumGrades，\n以及需要擴充的 class：SumStudentsGradesWithHakkaPlus10、sumStudentsGradesOriginalWay\nclass SumGrades { sum() { throw \"please implement by your self\"; } } class SumStudentsGradesWithHakkaPlus10 extends SumGrades { sum(students) { return students.reduce((acc, student) =\u003e { const additionalScore = student.isHakka ? 10 : 0; return acc + student.grade + additionalScore; }, 0); } } class sumStudentsGradesOriginalWay extends SumGrades { sum(students) { return students.reduce((acc, student) =\u003e { return acc + student.grade; }, 0); } } 這裡需要獨立 SumGrades class 的原因，其實是為了確保他們有 sum 這個 funtion，必免 SumStudentsGrades 在呼叫時發生錯誤，同時也強迫每個擴充的 SumGrades 子類別實作自己的 sum funtion。\n使用方式就變成\n// or new sumStudentsGradesOriginalWay() const sumGrades = new SumStudentsGradesWithHakkaPlus10(); const studentsGrades = new SumStudentsGrades(studens, sumGrades); studentsGrades.sum(); 當需要不同的加總規則時，我們只要新增一個 class 檔案並且繼承 SumGrades 就好，而不必去動到 SumStudentsGrades 類別 這樣一來就符合了 OCP。\nReact 的範例 情境： 有個呈現所有使用者列表的頁面，上面的內容需要根據 user 的性別（gender），來提供不同的 layout\n先來一些 user 資料\nconst data = [ { name: \"小黑\", gender: \"boy\" }, { name: \"小白\", gender: \"boy\" }, { name: \"小紅\", gender: \"girl\" }, ]; 接者用 map 來 render 這些資料\nconst UserListPage = () =\u003e { const [userData] = useState(data); return ( \u003cdiv\u003e {userData.map((user, index) =\u003e { return \u003cUserDetail user={user} key={index} /\u003e; })} \u003c/div\u003e ); }; 列表邏輯處理好後，來看看 UserDetail 有什麼規則\n業主說：\n如果是男生，外框用藍色的，大頭貼用正方形。 如果是女生，外框用紅色的，大頭貼用圓形。 OK，沒什麼問題直接來做吧。\nconst UserDetail = ({ user }) =\u003e { return ( \u003cdiv style={{ // 男生藍色、女生紅色 border: user.gender === \"boy\" ? \"1px solid blue\" : \"1px solid red\", marginBottom: \"10px\", padding: \"10px 0\", }} \u003e \u003cdiv\u003e \u003cimg style={{ // 男生正方形、女生圓形 borderRadius: user.gender === \"boy\" ? \"0\" : \"50%\", }} src=\"https://via.placeholder.com/30x30\" alt=\"\" /\u003e \u003c/div\u003e \u003cdiv\u003e{user.name}\u003c/div\u003e \u003cdiv\u003e{user.gender}\u003c/div\u003e \u003c/div\u003e ); }; 看起來大致上好了， 而且老實說我覺得這也是在 React 上很正常的設計方式\n不過可以回想一下前面說的 擴充 概念：\n在原本的功能上擴充一些東西，但別人想用原本的功能也不影響，是可以選擇的。\n我們可以想像說，原本的 app 只有男生的樣式，但後來想要擴充女生的樣式，而男生的樣式也要保留下來 （雖然實務上，這個 case 應該是兩者同時發生拉）\n如果以這個邏輯去想，當我要擴充女生樣式的功能時，是不是只能去 修改 UserDetail 檔案（使用 if 判斷）， 而不是用 擴充 方式多出一個檔案？ 好像就違反了 OCP，那該怎麼做？\n很簡單就是將他們拆成兩個 component\nBoy 變成 UserDetailBoy\nconst UserDetailBoy = ({ user }) =\u003e { return ( \u003cdiv style={{ border: \"1px solid blue\", marginBottom: \"10px\", padding: \"10px 0\" }} \u003e \u003cdiv\u003e \u003cimg src=\"https://via.placeholder.com/30x30\" alt=\"\" /\u003e \u003c/div\u003e \u003cdiv\u003e{user.name}\u003c/div\u003e \u003cdiv\u003e{user.gender}\u003c/div\u003e \u003c/div\u003e ); }; Girl 變成 UserDetailGirl\nconst UserDetailGirl = ({ user }) =\u003e { return ( \u003cdiv style={{ border: \"1px solid red\", marginBottom: \"10px\", padding: \"10px 0\" }} \u003e \u003cdiv\u003e \u003cimg style={{ borderRadius: \"50%\" }} src=\"https://via.placeholder.com/30x30\" alt=\"\" /\u003e \u003c/div\u003e \u003cdiv\u003e{user.name}\u003c/div\u003e \u003cdiv\u003e{user.gender}\u003c/div\u003e \u003c/div\u003e ); }; 原本的 UserDetail 也修改一下\nconst UserDetail = ({ user }) =\u003e { const components = { boy: \u003cUserDetailBoy /\u003e, girl: \u003cUserDetailGirl /\u003e }; return components[user.gender]; }; OK 完成了，我們 code 看起來變得又臭又長，別著急請聽我娓娓道來。\n假如不這麼做，如果未來多了 中性 的性別樣式，是不是又要在 UserDetail 再加上一些 if 來呈現？\n而且除了性別之外\n或許還會有 VIP 使用者，他的樣式要跟別人不同，藉此凸顯尊貴感。 或許還會有 Admin 使用者，業主說需要隱藏起來。 ……等 我們可以想像 UserDetail 應該會變得越來越複雜，裡面將會充滿著各種身份邏輯的判斷。\n但如果使用 OCP 的寫法，是不是就不用考慮這些問題？ 有新的邏輯時就直接新增一個 component 來擴充，不必更改 UserDetail 檔案，有沒有感覺簡單一些？\n事實上還可以再思考一個情境，如果 app 想要開發一個女性使用者專區，裡面的列表只需要呈現女性， 而當你準備使用 UserDetail 時，你發現裡面 style 上很多 if else，你會不會用的很不安心？結果最後決定重寫一個 UserDetailGirl， 然後就發現這不是 OCP 嗎？\nOCP 總結 在讀 OCP 之前，我常常將一個 component 設計成很多狀態，有要使用的人再傳對應的參數就好，這樣我的 code 寫得少而且又像一把瑞士刀一樣萬用，但後來想想一切並非這個美好，很多時候因為 component 裡面實在太複雜，導致根本不敢重複使用，很怕哪個參數沒有確定好，結果呈現出了不需要的狀態。\n雖然 OCP 真的是很棒的原則，但在開發的時也不必太執著於它，一定要將 JSX 裡面的所有 if 都滅絕，反倒是自己可以稍微衡量一下這個功能的潛在擴充性，如果短期不會有這個需求，其實直接用 if 解決也不會怎樣， 能夠在這之中取得平衡點，我覺得才是一個正確的開發習慣。\nReferences Open-closed principle Applying the Open-Closed Principle To Write Clean React Components 深入淺出開放封閉原則 Open-Closed Principle ","wordCount":"722","inLanguage":"en","datePublished":"2022-06-23T02:27:06+08:00","dateModified":"2022-06-23T02:27:06+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-with-react-ocp/"},"publisher":{"@type":"Organization","name":"Hakka Blog","logo":{"@type":"ImageObject","url":"https://curt6815463.github.io/hakka-dev-blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://curt6815463.github.io/hakka-dev-blog/ accesskey=h title="Hakka Blog (Alt + H)">Hakka Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SOLID Principles With React - OCP</h1><div class=post-meta><span title='2022-06-23 02:27:06 +0800 +0800'>June 23, 2022</span></div></header><div class=post-content><p>Hi 大家好我是 Curt 家人</p><h1 id=系列相關文章>系列相關文章<a hidden class=anchor aria-hidden=true href=#系列相關文章>#</a></h1><ul><li><a href=https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-with-react/>SOLID Principles With React</a></li><li><a href=https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-with-react-srp/>SOLID Principles With React - SRP（單一職責原則）</a></li><li><a href=https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-with-react-lsp/>SOLID Principles With React - LSP（里氏替換原則）</a></li><li>Interface segregation principle (ISP) - 介面隔離原則</li><li>Dependency inversion principle (DIP) - 依賴反轉原則</li></ul><h1 id=ocp>OCP<a hidden class=anchor aria-hidden=true href=#ocp>#</a></h1><p>SOLID 的第二個原則 OCP，中文又稱作開放封閉原則，意思是說</p><p>我允許我的 class、module、function 給你擴充，但不允許你修改它</p><p>定義上也是這麼說</p><blockquote><p>software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification</p></blockquote><p>我們先來釐清什麼是擴充、什麼是修改</p><ul><li>擴充：在原本的功能上擴充一些東西，但別人想用原本的功能也不影響，是可以選擇的。</li><li>修改：將核心的邏輯、功能換掉，所有人都會用到同一個功能。</li></ul><p>舉個生活中的例子，
EX: 機車是用來交通的工具，如果有導航需求自己可以加裝手機架，給其他人騎的時候，如果他覺得不需要可以隨時拆掉，不影響原本的功用。</p><p>因此當有一個需求會影響這個 class 時，需要思考一下它是 <code>擴充</code> 還是 <code>修改</code>，</p><ul><li>如果是擴充：那不應該修改這個檔案的 code，而是進行擴充</li><li>如果是修改：那就直接改檔案把。</li></ul><p>我們來延續 SRP 中物件導向的例子</p><h2 id=ocp-物件導向的範例>OCP 物件導向的範例<a hidden class=anchor aria-hidden=true href=#ocp-物件導向的範例>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SumStudentsGrades</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>students</span> <span style=color:#f92672>=</span> []) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>students</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>students</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sum</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>students</span>.<span style=color:#a6e22e>reduce</span>((<span style=color:#a6e22e>acc</span>, <span style=color:#a6e22e>student</span>) =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>acc</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>student</span>.<span style=color:#a6e22e>grade</span>;
</span></span><span style=display:flex><span>    }, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>studentA</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;小劉&#34;</span>, <span style=color:#a6e22e>grade</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>20</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>studentB</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;小紅&#34;</span>, <span style=color:#a6e22e>grade</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>30</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>studentC</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;小白&#34;</span>, <span style=color:#a6e22e>grade</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>40</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>studens</span> <span style=color:#f92672>=</span> [<span style=color:#a6e22e>studentA</span>, <span style=color:#a6e22e>studentB</span>, <span style=color:#a6e22e>studentC</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>studentsGrades</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>StudentsGrades</span>(<span style=color:#a6e22e>studens</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>studentsGrades</span>.<span style=color:#a6e22e>sum</span>();
</span></span></code></pre></div><p>前面有提到，全班成績的加總算法可能會更動，像是客家人身份要多 10 分，那我們思考一下這樣算是 <code>擴充</code> 還是 <code>修改</code>？</p><p>答案是我覺得兩個都有可能，首先要問一下 user</p><ol><li>以後都固定這樣算嗎？ （修改）</li><li>還是要提供兩種算法，讓大家自由決定要拿原始的加總成績還是加權後的加總成績 （擴充）</li></ol><p>假如最後確認的需求是擴充，但我卻直接修改 SumStudentsGrades 會變怎樣呢？我們來看看</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SumStudentsGrades</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>students</span> <span style=color:#f92672>=</span> [], <span style=color:#a6e22e>sumFormulaType</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>students</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>students</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>sumFormulaType</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>sumFormulaType</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sum</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>sumFormulaType</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;hakkaPlus10&#34;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>students</span>.<span style=color:#a6e22e>reduce</span>((<span style=color:#a6e22e>acc</span>, <span style=color:#a6e22e>student</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>additionalScore</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>student</span>.<span style=color:#a6e22e>isHakka</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>acc</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>student</span>.<span style=color:#a6e22e>grade</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>additionalScore</span>;
</span></span><span style=display:flex><span>      }, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>students</span>.<span style=color:#a6e22e>reduce</span>((<span style=color:#a6e22e>acc</span>, <span style=color:#a6e22e>student</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>acc</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>student</span>.<span style=color:#a6e22e>grade</span>;
</span></span><span style=display:flex><span>      }, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在使用 SumStudentsGrades 時，我們多傳入一個參數 <code>hakkaPlus10</code>，用它來決定我們的加總算法</p><p>使用時變這樣</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>sumFormulaType</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hakkaPlus10&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>studentsGrades</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>SumStudentsGrades</span>(<span style=color:#a6e22e>studens</span>, <span style=color:#a6e22e>sumFormulaType</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 最後結果: 100
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>studentsGrades</span>.<span style=color:#a6e22e>sum</span>();
</span></span></code></pre></div><p>看起來沒問題，不過以後想要擴充其他功能，EX: 原住民加 20 分，那我不就要增加一個 <code>if</code> 在 <code>SumStudentsGrades</code>？ 所以違反 OCP</p><p>那可以怎麼改呢？
首先將 sum 的邏輯 <code>委派</code> 給其他 class，原本的 class 只需要呼叫他的 function 就好</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SumStudentsGrades</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>students</span> <span style=color:#f92672>=</span> [], <span style=color:#a6e22e>sumGrades</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>students</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>students</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>sumGrades</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>sumGrades</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sum</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sumGrades</span>.<span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>students</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接著建立負責處理 sum 的 class：SumGrades，</p><p>以及需要擴充的 class：SumStudentsGradesWithHakkaPlus10、sumStudentsGradesOriginalWay</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SumGrades</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sum</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#e6db74>&#34;please implement by your self&#34;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SumStudentsGradesWithHakkaPlus10</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>SumGrades</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sum</span>(<span style=color:#a6e22e>students</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>students</span>.<span style=color:#a6e22e>reduce</span>((<span style=color:#a6e22e>acc</span>, <span style=color:#a6e22e>student</span>) =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>additionalScore</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>student</span>.<span style=color:#a6e22e>isHakka</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>acc</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>student</span>.<span style=color:#a6e22e>grade</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>additionalScore</span>;
</span></span><span style=display:flex><span>    }, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>sumStudentsGradesOriginalWay</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>SumGrades</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sum</span>(<span style=color:#a6e22e>students</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>students</span>.<span style=color:#a6e22e>reduce</span>((<span style=color:#a6e22e>acc</span>, <span style=color:#a6e22e>student</span>) =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>acc</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>student</span>.<span style=color:#a6e22e>grade</span>;
</span></span><span style=display:flex><span>    }, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>這裡需要獨立 SumGrades class 的原因，其實是為了確保他們有 sum 這個 funtion，必免 SumStudentsGrades 在呼叫時發生錯誤，同時也強迫每個擴充的 SumGrades 子類別實作自己的 sum funtion。</p><p>使用方式就變成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// or new sumStudentsGradesOriginalWay()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>sumGrades</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>SumStudentsGradesWithHakkaPlus10</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>studentsGrades</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>SumStudentsGrades</span>(<span style=color:#a6e22e>studens</span>, <span style=color:#a6e22e>sumGrades</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>studentsGrades</span>.<span style=color:#a6e22e>sum</span>();
</span></span></code></pre></div><p>當需要不同的加總規則時，我們只要新增一個 class 檔案並且繼承 SumGrades 就好，而不必去動到 SumStudentsGrades 類別
這樣一來就符合了 OCP。</p><h2 id=react-的範例>React 的範例<a hidden class=anchor aria-hidden=true href=#react-的範例>#</a></h2><p>情境： 有個呈現所有使用者列表的頁面，上面的內容需要根據 user 的性別（gender），來提供不同的 layout</p><p>先來一些 user 資料</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;小黑&#34;</span>, <span style=color:#a6e22e>gender</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;boy&#34;</span> },
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;小白&#34;</span>, <span style=color:#a6e22e>gender</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;boy&#34;</span> },
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;小紅&#34;</span>, <span style=color:#a6e22e>gender</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;girl&#34;</span> },
</span></span><span style=display:flex><span>];
</span></span></code></pre></div><p>接者用 map 來 render 這些資料</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-react data-lang=react><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>UserListPage</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>userData</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      {<span style=color:#a6e22e>userData</span>.<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>index</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>UserDetail</span> <span style=color:#a6e22e>user</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>user</span>} <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>index</span>} /&gt;;
</span></span><span style=display:flex><span>      })}
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>列表邏輯處理好後，來看看 UserDetail 有什麼規則</p><p>業主說：</p><ul><li>如果是男生，外框用藍色的，大頭貼用正方形。</li><li>如果是女生，外框用紅色的，大頭貼用圓形。</li></ul><p>OK，沒什麼問題直接來做吧。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-react data-lang=react><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>UserDetail</span> <span style=color:#f92672>=</span> ({ <span style=color:#a6e22e>user</span> }) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>style</span><span style=color:#f92672>=</span>{{
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 男生藍色、女生紅色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>border</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>gender</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;boy&#34;</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;1px solid blue&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;1px solid red&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>marginBottom</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;10px&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>padding</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;10px 0&#34;</span>,
</span></span><span style=display:flex><span>      }}
</span></span><span style=display:flex><span>    &gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>img</span>
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>style</span><span style=color:#f92672>=</span>{{
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 男生正方形、女生圓形
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>borderRadius</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>gender</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;boy&#34;</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;50%&#34;</span>,
</span></span><span style=display:flex><span>          }}
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;https://via.placeholder.com/30x30&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>alt</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>        /&gt;
</span></span><span style=display:flex><span>      &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>div</span>&gt;{<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>name</span>}&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>div</span>&gt;{<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>gender</span>}&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>看起來大致上好了，
而且老實說我覺得這也是在 React 上很正常的設計方式</p><p>不過可以回想一下前面說的 <code>擴充</code> 概念：</p><blockquote><p>在原本的功能上擴充一些東西，但別人想用原本的功能也不影響，是可以選擇的。</p></blockquote><p>我們可以想像說，原本的 app 只有男生的樣式，但後來想要擴充女生的樣式，而男生的樣式也要保留下來 （雖然實務上，這個 case 應該是兩者同時發生拉）</p><p>如果以這個邏輯去想，當我要擴充女生樣式的功能時，是不是只能去 <code>修改</code> UserDetail 檔案（使用 if 判斷），
而不是用 <code>擴充</code> 方式多出一個檔案？ 好像就違反了 OCP，那該怎麼做？</p><p>很簡單就是將他們拆成兩個 component</p><p>Boy 變成 UserDetailBoy</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-react data-lang=react><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>UserDetailBoy</span> <span style=color:#f92672>=</span> ({ <span style=color:#a6e22e>user</span> }) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>style</span><span style=color:#f92672>=</span>{{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>border</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;1px solid blue&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>marginBottom</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;10px&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>padding</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;10px 0&#34;</span>
</span></span><span style=display:flex><span>      }}
</span></span><span style=display:flex><span>    &gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;https://via.placeholder.com/30x30&#34;</span> <span style=color:#a6e22e>alt</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span> /&gt;
</span></span><span style=display:flex><span>      &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>div</span>&gt;{<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>name</span>}&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>div</span>&gt;{<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>gender</span>}&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Girl 變成 UserDetailGirl</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-react data-lang=react><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>UserDetailGirl</span> <span style=color:#f92672>=</span> ({ <span style=color:#a6e22e>user</span> }) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>style</span><span style=color:#f92672>=</span>{{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>border</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;1px solid red&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>marginBottom</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;10px&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>padding</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;10px 0&#34;</span>
</span></span><span style=display:flex><span>      }}
</span></span><span style=display:flex><span>    &gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>img</span>
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>style</span><span style=color:#f92672>=</span>{{ <span style=color:#a6e22e>borderRadius</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;50%&#34;</span> }}
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;https://via.placeholder.com/30x30&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>alt</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>        /&gt;
</span></span><span style=display:flex><span>      &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>div</span>&gt;{<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>name</span>}&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>div</span>&gt;{<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>gender</span>}&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>原本的 UserDetail 也修改一下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-react data-lang=react><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>UserDetail</span> <span style=color:#f92672>=</span> ({ <span style=color:#a6e22e>user</span> }) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>components</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>boy</span><span style=color:#f92672>:</span> &lt;<span style=color:#f92672>UserDetailBoy</span> /&gt;,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>girl</span><span style=color:#f92672>:</span> &lt;<span style=color:#f92672>UserDetailGirl</span> /&gt;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>components</span>[<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>gender</span>];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>OK 完成了，我們 code 看起來變得又臭又長，別著急請聽我娓娓道來。</p><p>假如不這麼做，如果未來多了 <code>中性</code> 的性別樣式，是不是又要在 UserDetail 再加上一些 if 來呈現？</p><p>而且除了性別之外</p><ul><li>或許還會有 VIP 使用者，他的樣式要跟別人不同，藉此凸顯尊貴感。</li><li>或許還會有 Admin 使用者，業主說需要隱藏起來。</li><li>&mldr;&mldr;等</li></ul><p>我們可以想像 UserDetail 應該會變得越來越複雜，裡面將會充滿著各種身份邏輯的判斷。</p><p>但如果使用 OCP 的寫法，是不是就不用考慮這些問題？ 有新的邏輯時就直接新增一個 component 來擴充，不必更改 UserDetail 檔案，有沒有感覺簡單一些？</p><p>事實上還可以再思考一個情境，如果 app 想要開發一個女性使用者專區，裡面的列表只需要呈現女性，
而當你準備使用 UserDetail 時，你發現裡面 style 上很多 if else，你會不會用的很不安心？結果最後決定重寫一個 UserDetailGirl，
然後就發現這不是 OCP 嗎？</p><h2 id=ocp-總結>OCP 總結<a hidden class=anchor aria-hidden=true href=#ocp-總結>#</a></h2><p>在讀 OCP 之前，我常常將一個 component 設計成很多狀態，有要使用的人再傳對應的參數就好，這樣我的 code 寫得少而且又像一把瑞士刀一樣萬用，但後來想想一切並非這個美好，很多時候因為 component 裡面實在太複雜，導致根本不敢重複使用，很怕哪個參數沒有確定好，結果呈現出了不需要的狀態。</p><p>雖然 OCP 真的是很棒的原則，但在開發的時也不必太執著於它，一定要將 JSX 裡面的所有 if 都滅絕，反倒是自己可以稍微衡量一下這個功能的潛在擴充性，如果短期不會有這個需求，其實直接用 if 解決也不會怎樣，
能夠在這之中取得平衡點，我覺得才是一個正確的開發習慣。</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle>Open-closed principle</a></li><li><a href=https://betterprogramming.pub/applying-the-open-closed-principle-to-write-clean-react-components-4e4514963e40>Applying the Open-Closed Principle To Write Clean React Components</a></li><li><a href=https://www.jyt0532.com/2020/03/19/ocp/>深入淺出開放封閉原則 Open-Closed Principle</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://curt6815463.github.io/hakka-dev-blog/>Hakka Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>