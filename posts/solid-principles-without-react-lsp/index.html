<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID Principles without React - LSP | Hakka Blog</title><meta name=keywords content><meta name=description content="Hi 大家好我是 Curt 家人
系列相關文章 SOLID Principles With React SOLID Principles With React - SRP (單一職責原則) SOLID Principles With React - OCP (開放封閉原則) SOLID Principles Without React - LSP (里氏替換原則) SOLID Principles With React - ISP (介面隔離原則) SOLID Principles With React - DIP (依賴反轉原則) LSP 前言 這篇文章要來介紹不好理解的原則：里氏替換原則，開始讀的時候可能很容易一頭霧水，並且網路上有蠻多 Bird 、 Duck 與 Triangle 的範例，自己看完之後還是有點沒想法， 不過隨著看越多的相關文章，好像就可以慢慢地體會到核心理念，並且要達到他的要求好像也不難。
wiki 的資料中有提到：LSP 在論文內說明 subtyping 的擴充行為與 design by contract 有著相似的概念，因此以下也會將其一起說明。
在開始之前需要提醒一下，因為 LSP 強調的是物件繼承間的問題，也就是子類與父類的繼承關係合不合適，然而 React 的開發風格不需使用繼承，每個 component 只需要 extends React 就好， 因此本篇不會有 React 的範例。"><meta name=author content><link rel=canonical href=https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-without-react-lsp/><link crossorigin=anonymous href=https://curt6815463.github.io/hakka-dev-blog/assets/css/stylesheet.min.3764877ba3a5494f5186c907876e4ed3f4d81cc8b5c752600f4d27d8cdfd1b45.css integrity="sha256-N2SHe6OlSU9RhskHh25O0/TYHMi1x1JgD00n2M39G0U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=https://curt6815463.github.io/hakka-dev-blog/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script> <link rel=icon href=https://curt6815463.github.io/hakka-dev-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://curt6815463.github.io/hakka-dev-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://curt6815463.github.io/hakka-dev-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://curt6815463.github.io/hakka-dev-blog/apple-touch-icon.png><link rel=mask-icon href=https://curt6815463.github.io/hakka-dev-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=https://curt6815463.github.io/hakka-dev-blog/css/custom.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="SOLID Principles without React - LSP"><meta property="og:description" content="Hi 大家好我是 Curt 家人
系列相關文章 SOLID Principles With React SOLID Principles With React - SRP (單一職責原則) SOLID Principles With React - OCP (開放封閉原則) SOLID Principles Without React - LSP (里氏替換原則) SOLID Principles With React - ISP (介面隔離原則) SOLID Principles With React - DIP (依賴反轉原則) LSP 前言 這篇文章要來介紹不好理解的原則：里氏替換原則，開始讀的時候可能很容易一頭霧水，並且網路上有蠻多 Bird 、 Duck 與 Triangle 的範例，自己看完之後還是有點沒想法， 不過隨著看越多的相關文章，好像就可以慢慢地體會到核心理念，並且要達到他的要求好像也不難。
wiki 的資料中有提到：LSP 在論文內說明 subtyping 的擴充行為與 design by contract 有著相似的概念，因此以下也會將其一起說明。
在開始之前需要提醒一下，因為 LSP 強調的是物件繼承間的問題，也就是子類與父類的繼承關係合不合適，然而 React 的開發風格不需使用繼承，每個 component 只需要 extends React 就好， 因此本篇不會有 React 的範例。"><meta property="og:type" content="article"><meta property="og:url" content="https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-without-react-lsp/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-25T17:03:35+08:00"><meta property="article:modified_time" content="2022-06-25T17:03:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID Principles without React - LSP"><meta name=twitter:description content="Hi 大家好我是 Curt 家人
系列相關文章 SOLID Principles With React SOLID Principles With React - SRP (單一職責原則) SOLID Principles With React - OCP (開放封閉原則) SOLID Principles Without React - LSP (里氏替換原則) SOLID Principles With React - ISP (介面隔離原則) SOLID Principles With React - DIP (依賴反轉原則) LSP 前言 這篇文章要來介紹不好理解的原則：里氏替換原則，開始讀的時候可能很容易一頭霧水，並且網路上有蠻多 Bird 、 Duck 與 Triangle 的範例，自己看完之後還是有點沒想法， 不過隨著看越多的相關文章，好像就可以慢慢地體會到核心理念，並且要達到他的要求好像也不難。
wiki 的資料中有提到：LSP 在論文內說明 subtyping 的擴充行為與 design by contract 有著相似的概念，因此以下也會將其一起說明。
在開始之前需要提醒一下，因為 LSP 強調的是物件繼承間的問題，也就是子類與父類的繼承關係合不合適，然而 React 的開發風格不需使用繼承，每個 component 只需要 extends React 就好， 因此本篇不會有 React 的範例。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://curt6815463.github.io/hakka-dev-blog/posts/"},{"@type":"ListItem","position":2,"name":"SOLID Principles without React - LSP","item":"https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-without-react-lsp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID Principles without React - LSP","name":"SOLID Principles without React - LSP","description":"Hi 大家好我是 Curt 家人\n系列相關文章 SOLID Principles With React SOLID Principles With React - SRP (單一職責原則) SOLID Principles With React - OCP (開放封閉原則) SOLID Principles Without React - LSP (里氏替換原則) SOLID Principles With React - ISP (介面隔離原則) SOLID Principles With React - DIP (依賴反轉原則) LSP 前言 這篇文章要來介紹不好理解的原則：里氏替換原則，開始讀的時候可能很容易一頭霧水，並且網路上有蠻多 Bird 、 Duck 與 Triangle 的範例，自己看完之後還是有點沒想法， 不過隨著看越多的相關文章，好像就可以慢慢地體會到核心理念，並且要達到他的要求好像也不難。\nwiki 的資料中有提到：LSP 在論文內說明 subtyping 的擴充行為與 design by contract 有著相似的概念，因此以下也會將其一起說明。\n在開始之前需要提醒一下，因為 LSP 強調的是物件繼承間的問題，也就是子類與父類的繼承關係合不合適，然而 React 的開發風格不需使用繼承，每個 component 只需要 extends React 就好， 因此本篇不會有 React 的範例。","keywords":[],"articleBody":"Hi 大家好我是 Curt 家人\n系列相關文章 SOLID Principles With React SOLID Principles With React - SRP (單一職責原則) SOLID Principles With React - OCP (開放封閉原則) SOLID Principles Without React - LSP (里氏替換原則) SOLID Principles With React - ISP (介面隔離原則) SOLID Principles With React - DIP (依賴反轉原則) LSP 前言 這篇文章要來介紹不好理解的原則：里氏替換原則，開始讀的時候可能很容易一頭霧水，並且網路上有蠻多 Bird 、 Duck 與 Triangle 的範例，自己看完之後還是有點沒想法， 不過隨著看越多的相關文章，好像就可以慢慢地體會到核心理念，並且要達到他的要求好像也不難。\nwiki 的資料中有提到：LSP 在論文內說明 subtyping 的擴充行為與 design by contract 有著相似的概念，因此以下也會將其一起說明。\n在開始之前需要提醒一下，因為 LSP 強調的是物件繼承間的問題，也就是子類與父類的繼承關係合不合適，然而 React 的開發風格不需使用繼承，每個 component 只需要 extends React 就好， 因此本篇不會有 React 的範例。\n開始介紹 LSP 的全文叫做 Liskov substitution principle，Liskov 是作者的名字，substitution 則是替換性也是這個原則所要探討的點。\n何謂替換性？\nif S is a subtype of T, then objects of type T in a program may be replaced with objects of type S - wiki\n如果 S 是 T 的子類型，那麼程序中的所有 T 都能被換成 Ｓ\n除此之外後面有繼續補充\nwithout altering any of the desirable properties of that program - wiki\n白話一點就是：取代之後，不用改 code 的程序也不會因為我的替換 (substitution) 而壞掉。\n舉個簡單的範例：\n假設有兩個 class: A B, B 繼承 A\nclass A { doWork() { console.log(\"do work\"); } } class B extends A { doAnotherWork() { console.log(\"do another work\"); } } 然後在程式的某部分，使用了 A 的功能\n// ... const a = new A(); a.doWork(); // ... 假如這時 a 替換成 b 程式會壞嗎？\n// ... const a = new B(); // A 換成 B a.doWork(); // ... 不會，程式還是能照常的運行，也不會有錯誤， 因此這個情況符合 LSP\n這只是個簡單的範例，讓你了解替換的概念是什麼，而實際上有一些準則告訴我們，子類繼承父類時有哪些事情我要需要遵守，才不會破壞 LSP\nDesign by contract (Contract Rules) 根據合約來設計程式，總共有三條規則需要遵守。\nPreconditions cannot be strengthened in a subtype. Postconditions cannot be weakened. Invariants of the supertype must be preserved in a subtype. Preconditions cannot be strengthened in a subtype. 子類的前置條件不能比父類 strengthened （我會翻成嚴苛）\n不過我們先來理解 Precondition (前置條件) 是什麼，有時候我們執行 function 時，會希望有滿足某些條件才做裡面的事\n簡單的例子： 計算正方形面積\nfunction calcSquareArea(length) { return length * length; } 但可能會希望 length 是大於 0 的數字，因此改成\nfunction calcSquareArea(length) { // if 的條件就是前置條件 if (typeof length === \"number\" \u0026\u0026 length \u003e 0) { return length * length; } } 那如果子類要重新實作父類的 function 時，前置條件比較嚴格會怎樣？\nclass A { getValue(value) { if (typeof value === \"number\") { return value + 10; } } } class B extends A { getValue(value) { // B 除了判斷是否為數字之外，還多一個限制是要大於 0 if (typeof value === \"number\" \u0026\u0026 value \u003e 0) { return value + 20; } } } 某個地方的 class A 呼叫 getValue 替換成 class B 時有可能會壞掉\nlet a = new A(); a.getValue(-10); // result 0 // 使用替換 let a = new B(); b.getValue(-10); // 什麼都沒有 undefined 這樣一來就不能替換了，因此違反 LSP\nPostconditions cannot be weakened 後置條件不能比較 weakened (我會翻成鬆散)\n後置條件主要是為了確保 function 回傳的值是有效的，像是型別有沒有正確、資料範圍有沒有誤\n舉個簡單例子：計算訂單金額\nfunction calcOrderPrice(orders) { let price = 0; // 計算訂單金額，假設有一系列算法：運費、會員身份...等 //最後 return 前的後置條件 if (typeof price === \"number\" \u0026\u0026 price \u003e 0) { return price; } } 一樣如果子類要重新實作父類的 function 時，後置條件比較鬆散會怎樣？\nEX: 移除大於 0 判斷。\nfunction calcOrderPrice(orders) { let price = 0; if (typeof price === \"number\") { return price; } } 這樣一來替換成子類的時候，client 端可能會拿到小於 0 的訂單金額，導致後續的系統流程有誤，因此不符合 LSP\nInvariants of the supertype must be preserved in a subtype 父類的 invariant 邏輯應該被子類保留 (不變性)\n主要是在強調 資料 的不變性，假如父類別上有一些保護機制，能夠確保資料是有效的，而子類在實作時就應該維持這個特性，不該去改變它。\n保護機制有可能像是前面提到的 precondition 或是 postcondition。\n舉個例子：取得訂單價格\nclass OrderPrice { constructor(price) { if (price \u003c 0) { throw \"price should not less than 0\"; } this.price = price; } } class VipUserOrderPrice extends OrderPrice { setPrice(price) { this.price = price; } } const vipOrderPrice = new VipUserOrderPrice(); vipOrderPrice.setPrice(-20); 在 contructor 時，OrderPrice 為了避免價格小於零的訂單出現，因此設定了 price \u003c 0 throw error 的條件，\n而 VipUserOrderPrice 卻提供了一個 setPrice function，可能會造成資料出現小於 0 的狀況。\n所以問題又來，如果在有使用 OrderPrice 的地方，將它替換成 VipUserOrderPrice，會讓程式壞嗎？當然有機會，因此也不符合 LSP\n在這個案例中，比較好的做法應該是將 set price 的邏輯，放回父類，由父類來保留他原生的邏輯來達到不變性。\nclass OrderPrice { setPrice(price) { if (price \u003c 0) { throw \"price should not less than 0\"; } this.price = price; } } 替換的目的 文章到目前為止都在說明什麼情況替換類別才符合 LSP，或是替換的條件有哪些以及該注意的點，但既然已經知道了這些，那我就會思考說為什麼要替換？它的好處是什麼？\n我覺得主要是為了讓 client 端在使用這些子類別時，能夠對它有些基本的認知，因而不容易產生 bug，\n還是要回到鳥的例子一下，假如宣告了一隻 Bird 的類別，上面有 fly、walk 的功能，然後另外宣告了企鵝的類別，讓其繼承 Bird\nclass Bird { walk() { console.log(\"walk\"); } fly() { console.log(\"fly\"); } } class Penguin extends Bird { fly() { throw \"I can not fly\"; } } 讀到這裡我們也知道它違反了 LSP，在有使用 Bird 的地方，如果將他替換成 Penguin 一定有問題，企鵝就不會飛，只要一呼叫到程式就壞了，不過因為我們讀過生物，所以知道這件事情，因此可能就不會亂 call fly function。\n但程式在開發時候，client 可能沒有那麼多時間去了解每個類別的細節，有時候會先透過父類的功能來對它有個基本認識，而如果這時子類有個 funtion 跟父類有衝突不能呼叫或是邏輯大不相同， client 第一時間可能不會發現，導致 bug 的發生。\n這種情況也不禁讓我們懷疑，他們之間真的適合繼承嗎？ 而這個父類別好像也做了兩件事情，要走又要飛似乎違反單一職責 (SRP)，因此我們可以稍微改一下\nclass WalkBird { walk() { console.log('walk') } } class FlyBird { fly() { console.log(\"fly\"); } } class Penguin extends WalkBird { ... } LSP 總結 LSP 雖然很強調替換的部分，但我覺得更重要的是，當我們要提升某個抽象概念的父類時（也是就是所謂 一般化 (generalization)），應該要想清楚他的功能組合，是否都能應用到子類別上並且達到合約要求。\nReferences wiki The Liskov Substitution Principle - Microsoft Press Store object oriented design - Liskov substitution principle* clarification about the _history rule* - Software Engineering Stack Exchange 深入淺出 Liskov 替換原則 Liskov Substitution Principle\n","wordCount":"661","inLanguage":"en","datePublished":"2022-06-25T17:03:35+08:00","dateModified":"2022-06-25T17:03:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-without-react-lsp/"},"publisher":{"@type":"Organization","name":"Hakka Blog","logo":{"@type":"ImageObject","url":"https://curt6815463.github.io/hakka-dev-blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://curt6815463.github.io/hakka-dev-blog/ accesskey=h title="Hakka Blog (Alt + H)">Hakka Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SOLID Principles without React - LSP</h1><div class=post-meta><span title='2022-06-25 17:03:35 +0800 +0800'>June 25, 2022</span></div></header><div class=post-content><p>Hi 大家好我是 Curt 家人</p><h1 id=系列相關文章>系列相關文章<a hidden class=anchor aria-hidden=true href=#系列相關文章>#</a></h1><ul><li><a href=https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-with-react/>SOLID Principles With React</a></li><li><a href=https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-with-react-srp/>SOLID Principles With React - SRP (單一職責原則)</a></li><li><a href=https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-with-react-ocp/>SOLID Principles With React - OCP (開放封閉原則)</a></li><li><a href=https://curt6815463.github.io/hakka-dev-blog/posts/solid-principles-without-react-lsp/>SOLID Principles Without React - LSP (里氏替換原則)</a></li><li>SOLID Principles With React - ISP (介面隔離原則)</li><li>SOLID Principles With React - DIP (依賴反轉原則)</li></ul><h1 id=lsp>LSP<a hidden class=anchor aria-hidden=true href=#lsp>#</a></h1><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>這篇文章要來介紹不好理解的原則：<code>里氏替換原則</code>，開始讀的時候可能很容易一頭霧水，並且網路上有蠻多 Bird 、 Duck 與 Triangle 的範例，自己看完之後還是有點沒想法，
不過隨著看越多的相關文章，好像就可以慢慢地體會到核心理念，並且要達到他的要求好像也不難。</p><p><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle#:~:text=In%20the%20same%20paper%2C%20Liskov%20and%20Wing%20detailed%20their%20notion%20of%20behavioral%20subtyping%20in%20an%20extension%20of%20Hoare%20logic%2C%20which%20bears%20a%20certain%20resemblance%20to%20Bertrand%20Meyer%27s%20design%20by%20contract%20in%20that%20it%20considers%20the%20interaction%20of%20subtyping%20with%20preconditions%2C%20postconditions%20and%20invariants.">wiki</a> 的資料中有提到：LSP 在論文內說明 subtyping 的擴充行為與 design by contract 有著相似的概念，因此以下也會將其一起說明。</p><p>在開始之前需要提醒一下，因為 LSP 強調的是物件繼承間的問題，也就是子類與父類的繼承關係合不合適，然而 React 的開發風格不需使用繼承，每個 component 只需要 extends React 就好，
因此本篇不會有 React 的範例。</p><h2 id=開始介紹>開始介紹<a hidden class=anchor aria-hidden=true href=#開始介紹>#</a></h2><p>LSP 的全文叫做 Liskov substitution principle，Liskov 是作者的名字，substitution 則是替換性也是這個原則所要探討的點。</p><p>何謂替換性？</p><blockquote><p>if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S - <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle#:~:text=if%20S%20is%20a%20subtype%20of%20T%2C%20then%20objects%20of%20type%20T%20in%20a%20program%20may%20be%20replaced%20with%20objects%20of%20type%20S">wiki</a></p></blockquote><p>如果 S 是 T 的子類型，那麼程序中的所有 T 都能被換成 Ｓ</p><p>除此之外後面有繼續補充</p><blockquote><p>without altering any of the desirable properties of that program - <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle#cite_note-liskov1994-1:~:text=without%20altering%20any%20of%20the%20desirable%20properties%20of%20that%20program">wiki</a></p></blockquote><p>白話一點就是：取代之後，不用改 code 的程序也不會因為我的替換 (substitution) 而壞掉。</p><p>舉個簡單的範例：</p><p>假設有兩個 class: <code>A</code> <code>B</code>, B 繼承 A</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>doWork</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;do work&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>doAnotherWork</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;do another work&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然後在程式的某部分，使用了 A 的功能</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>A</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>doWork</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span></code></pre></div><p>假如這時 a 替換成 b 程式會壞嗎？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>B</span>(); <span style=color:#75715e>// A 換成 B
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>doWork</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span></code></pre></div><p>不會，程式還是能照常的運行，也不會有錯誤，
因此這個情況符合 LSP</p><p>這只是個簡單的範例，讓你了解替換的概念是什麼，而實際上有一些準則告訴我們，子類繼承父類時有哪些事情我要需要遵守，才不會破壞 LSP</p><h2 id=design-by-contract-contract-rules>Design by contract (Contract Rules)<a hidden class=anchor aria-hidden=true href=#design-by-contract-contract-rules>#</a></h2><p>根據合約來設計程式，總共有三條規則需要遵守。</p><ol><li>Preconditions cannot be strengthened in a subtype.</li><li>Postconditions cannot be weakened.</li><li>Invariants of the supertype must be preserved in a subtype.</li></ol><h3 id=preconditions-cannot-be-strengthened-in-a-subtype>Preconditions cannot be strengthened in a subtype.<a hidden class=anchor aria-hidden=true href=#preconditions-cannot-be-strengthened-in-a-subtype>#</a></h3><blockquote><p>子類的前置條件不能比父類 strengthened （我會翻成嚴苛）</p></blockquote><p>不過我們先來理解 Precondition (前置條件) 是什麼，有時候我們執行 function 時，會希望有滿足某些條件才做裡面的事</p><p>簡單的例子： 計算正方形面積</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calcSquareArea</span>(<span style=color:#a6e22e>length</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>length</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但可能會希望 length 是大於 0 的數字，因此改成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calcSquareArea</span>(<span style=color:#a6e22e>length</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// if 的條件就是前置條件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>length</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;number&#34;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>length</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>length</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>那如果子類要重新實作父類的 function 時，前置條件比較嚴格會怎樣？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getValue</span>(<span style=color:#a6e22e>value</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>value</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;number&#34;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>value</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getValue</span>(<span style=color:#a6e22e>value</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// B 除了判斷是否為數字之外，還多一個限制是要大於 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>value</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;number&#34;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>value</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>value</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>某個地方的 class A 呼叫 getValue 替換成 class B 時有可能會壞掉</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>A</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>getValue</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>); <span style=color:#75715e>// result 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用替換
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>B</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>getValue</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>); <span style=color:#75715e>// 什麼都沒有 undefined
</span></span></span></code></pre></div><p>這樣一來就不能替換了，因此違反 LSP</p><h3 id=postconditions-cannot-be-weakened>Postconditions cannot be weakened<a hidden class=anchor aria-hidden=true href=#postconditions-cannot-be-weakened>#</a></h3><blockquote><p>後置條件不能比較 weakened (我會翻成鬆散)</p></blockquote><p>後置條件主要是為了確保 function 回傳的值是有效的，像是型別有沒有正確、資料範圍有沒有誤</p><p>舉個簡單例子：計算訂單金額</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calcOrderPrice</span>(<span style=color:#a6e22e>orders</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>price</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 計算訂單金額，假設有一系列算法：運費、會員身份...等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//最後 return 前的後置條件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>price</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;number&#34;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>price</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>price</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一樣如果子類要重新實作父類的 function 時，後置條件比較鬆散會怎樣？</p><p>EX: 移除大於 0 判斷。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calcOrderPrice</span>(<span style=color:#a6e22e>orders</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>price</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>price</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;number&#34;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>price</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>這樣一來替換成子類的時候，client 端可能會拿到小於 0 的訂單金額，導致後續的系統流程有誤，因此不符合 LSP</p><h3 id=invariants-of-the-supertype-must-be-preserved-in-a-subtype>Invariants of the supertype must be preserved in a subtype<a hidden class=anchor aria-hidden=true href=#invariants-of-the-supertype-must-be-preserved-in-a-subtype>#</a></h3><blockquote><p>父類的 invariant 邏輯應該被子類保留 (<code>不變性</code>)</p></blockquote><p>主要是在強調 <code>資料</code> 的不變性，假如父類別上有一些保護機制，能夠確保資料是有效的，而子類在實作時就應該維持這個特性，不該去改變它。</p><p>保護機制有可能像是前面提到的 precondition 或是 postcondition。</p><p>舉個例子：取得訂單價格</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderPrice</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>price</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>price</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#e6db74>&#34;price should not less than 0&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>price</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>price</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VipUserOrderPrice</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>OrderPrice</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setPrice</span>(<span style=color:#a6e22e>price</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>price</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>price</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>vipOrderPrice</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>VipUserOrderPrice</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>vipOrderPrice</span>.<span style=color:#a6e22e>setPrice</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>20</span>);
</span></span></code></pre></div><p>在 contructor 時，OrderPrice 為了避免價格小於零的訂單出現，因此設定了 price &lt; 0 throw error 的條件，</p><p>而 VipUserOrderPrice 卻提供了一個 setPrice function，可能會造成資料出現小於 0 的狀況。</p><p>所以問題又來，如果在有使用 OrderPrice 的地方，將它替換成 VipUserOrderPrice，會讓程式壞嗎？當然有機會，因此也不符合 LSP</p><p>在這個案例中，比較好的做法應該是將 set price 的邏輯，放回父類，由父類來保留他原生的邏輯來達到不變性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderPrice</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setPrice</span>(<span style=color:#a6e22e>price</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>price</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#e6db74>&#34;price should not less than 0&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>price</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>price</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=替換的目的>替換的目的<a hidden class=anchor aria-hidden=true href=#替換的目的>#</a></h2><p>文章到目前為止都在說明什麼情況替換類別才符合 LSP，或是替換的條件有哪些以及該注意的點，但既然已經知道了這些，那我就會思考說為什麼要替換？它的好處是什麼？</p><p>我覺得主要是為了讓 client 端在使用這些子類別時，能夠對它有些基本的認知，因而不容易產生 bug，</p><p>還是要回到鳥的例子一下，假如宣告了一隻 Bird 的類別，上面有 fly、walk 的功能，然後另外宣告了企鵝的類別，讓其繼承 Bird</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bird</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>walk</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;walk&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fly</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;fly&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Penguin</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Bird</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fly</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#e6db74>&#34;I can not fly&#34;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>讀到這裡我們也知道它違反了 LSP，在有使用 Bird 的地方，如果將他替換成 Penguin 一定有問題，企鵝就不會飛，只要一呼叫到程式就壞了，不過因為我們讀過生物，所以知道這件事情，因此可能就不會亂 call fly function。</p><p>但程式在開發時候，client 可能沒有那麼多時間去了解每個類別的細節，有時候會先透過父類的功能來對它有個基本認識，而如果這時子類有個 funtion 跟父類有衝突不能呼叫或是邏輯大不相同，
client 第一時間可能不會發現，導致 bug 的發生。</p><p>這種情況也不禁讓我們懷疑，他們之間真的適合繼承嗎？ 而這個父類別好像也做了兩件事情，要走又要飛似乎違反單一職責 (SRP)，因此我們可以稍微改一下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WalkBird</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>walk</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;walk&#39;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FlyBird</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fly</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;fly&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Penguin</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>WalkBird</span> {
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=lsp-總結>LSP 總結<a hidden class=anchor aria-hidden=true href=#lsp-總結>#</a></h2><p>LSP 雖然很強調替換的部分，但我覺得更重要的是，當我們要提升某個抽象概念的父類時（也是就是所謂 <code>一般化 (generalization)</code>），應該要想清楚他的功能組合，是否都能應用到子類別上並且達到合約要求。</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Liskov_substitution_principle>wiki</a>
<a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2255313&seqNum=2">The Liskov Substitution Principle - Microsoft Press Store</a>
<a href=https://softwareengineering.stackexchange.com/questions/408686/liskov-substitution-principle-clarification-about-the-history-rule>object oriented design - Liskov substitution principle* clarification about the _history rule* - Software Engineering Stack Exchange</a>
<a href=https://www.jyt0532.com/2020/03/22/lsp/>深入淺出 Liskov 替換原則 Liskov Substitution Principle</a></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://curt6815463.github.io/hakka-dev-blog/>Hakka Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>