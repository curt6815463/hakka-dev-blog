<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Hakka Blog</title><meta name=keywords content><meta name=description content="Posts - Hakka Blog"><meta name=author content><link rel=canonical href=http://example.org/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.min.3764877ba3a5494f5186c907876e4ed3f4d81cc8b5c752600f4d27d8cdfd1b45.css integrity="sha256-N2SHe6OlSU9RhskHh25O0/TYHMi1x1JgD00n2M39G0U=" rel="preload stylesheet" as=style><link rel=icon href=http://example.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://example.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://example.org/favicon-32x32.png><link rel=apple-touch-icon href=http://example.org/apple-touch-icon.png><link rel=mask-icon href=http://example.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://example.org/posts/index.xml><link rel=stylesheet href=/css/custom.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://example.org/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://example.org/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://example.org/ accesskey=h title="Hakka Blog (Alt + H)">Hakka Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>SOLID Principles With React - OCP</h2></header><div class=entry-content><p>Hi 大家好我是 Curt 家人
系列相關文章 SOLID Principles With React Single responsibility principle (SRP) - 單一職責原則 Liskov substitution principle (LSP) - 里氏替換原則 Interface segregation principle (ISP) - 介面隔離原則 Dependency inversion principle (DIP) - 依賴反轉原則 OCP SOLID 的第二個原則 OCP，中文又稱作開放封閉原則，意思是說
我允許我的 class、module、function 給你擴充，但不允許你修改它
定義上也是這麼說
software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification
我們先來釐清什麼是擴充、什麼是修改
擴充：在原本的功能上擴充一些東西，但別人想用原本的功能也不影響，是可以選擇的。 修改：將核心的邏輯、功能換掉，所有人都會用到同一個功能。 舉個生活中的例子， EX: 機車是用來交通的工具，如果有導航需求自己可以加裝手機架，給其他人騎的時候，如果他覺得不需要可以隨時拆掉，不影響原本的功用。
因此當有一個需求會影響這個 class 時，需要思考一下它是 擴充 還是 修改，
如果是擴充：那不應該修改這個檔案的 code，而是進行擴充 如果是修改：那就直接改檔案把。 我們來延續 SRP 中物件導向的例子...</p></div><footer class=entry-footer><span title='2022-06-23 02:27:06 +0800 +0800'>June 23, 2022</span></footer><a class=entry-link aria-label="post link to SOLID Principles With React - OCP" href=http://example.org/posts/solid-principles-with-react-ocp/></a></article><article class=post-entry><header class=entry-header><h2>SOLID Principles With React - SRP</h2></header><div class=entry-content><p>Hi 大家好我是 Curt 家人
系列相關文章 SOLID Principles With React Open–closed principle (OCP) - 開放封閉原則 Liskov substitution principle (LSP) - 里氏替換原則 Interface segregation principle (ISP) - 介面隔離原則 Dependency inversion principle (DIP) - 依賴反轉原則 SRP 首先來看第一個規則 SRP，中文又叫單一職責原則， 其實從字面上可以很簡單的猜到他要表達的意思， 也就是說每個 module、class 或 function 只需要負責做一件事情就好，不要將太多無關或複雜的邏輯放在裡面。
比如說湯匙就是拿來挖食物的工具，但卻設計成可以挖食物又可以拿來當作吸管喝飲料的東西， 這樣一來如果要將吸管的功能改成可以彎折的效果，那就要考慮到會不會影響湯匙的功能，進而增加他們之間的耦合度。
我們來看一下定義是怎麼描述的
A class should have only one reason to change - Robert C. Martin
中文意思是 每個類別只能有一個可以修改它的理由
也就是說，如果某個類別出現了兩個理由要修改它，是不是就代表它做了兩件事情？ 因此不符合 SRP。
除此之外，封裝 也是 SRP 中很重要的事情，如果將功能拆成了好幾個元件，卻不知道怎麼用，那不如不要拆。
因此我們要能將元件的實作細節給隱藏起來，並提供一個很好的介面來讓使用者使用。
接著我們來看一些範例吧！
物件導向的範例 情境：需要一個類別來計算班上所有學生的分數總和，並且將結果輸出給使用者。...</p></div><footer class=entry-footer><span title='2022-06-23 02:25:32 +0800 +0800'>June 23, 2022</span></footer><a class=entry-link aria-label="post link to SOLID Principles With React - SRP" href=http://example.org/posts/solid-principles-with-react-srp/></a></article><article class=post-entry><header class=entry-header><h2>SOLID Principles With React</h2></header><div class=entry-content><p>Hi 大家好我是 Curt 家人
前言 最近在準備面試時候發現蠻多公司都會問 SOLID 這個題目， 雖然是面後端比較有機會被問到，不過我就在想如果面前端的時候被問到該怎麼回答比較好， 以及是否能夠提出一個合理的範例來沿用到 React 開發上。
Why SOLID SOLID 的概念是 2000 年由 Robert C. Martin 在此篇論文 - Design Principles and Design Patterns 內首次提出，主要是為了讓 物件導向 的程式設計可以有更好的 可讀性、維護性、彈性。
What is SOLID 它主要由五個原則所組成，分別為：
Single responsibility principle (SRP) - 單一職責原則 Open–closed principle (OCP) - 開放封閉原則 Liskov substitution principle (LSP) - 里氏替換原則 Interface segregation principle (ISP) - 介面隔離原則 Dependency inversion principle (DIP) - 依賴反轉原則 How to introduce SOLID 因為篇幅關係，我將會把這五個原則，分別在不同的文章內介紹，裡面的流程大概是...</p></div><footer class=entry-footer><span title='2022-06-21 21:07:20 +0800 +0800'>June 21, 2022</span></footer><a class=entry-link aria-label="post link to SOLID Principles With React" href=http://example.org/posts/solid-principles-with-react/></a></article><article class=post-entry><header class=entry-header><h2>React Fiber 初探</h2></header><div class=entry-content><p>React Fiber 廣義上可以代表整個新版架構，
而狹義上 Fiber 只是一個 object，這個 object 是 reconciler 藉由 react element 作為模板建立出來。
什麼是 React Element 平常寫 React Component 時，通常會在 render function 裡面使用 JSX 語法，而背後其實只是 JSX compiler 幫我們加入 React.createElement。
例如：
render(){ return( &lt;div onClick={() => null}> &lt;div>Hello Element&lt;/div> &lt;/div> ) } 會被轉成
render(){ return React.createElement( 'div', { onClick: myClick }, React.createElement('div', null, 'Hello Element'); ); } 如果直接將 createElement 的結果 console.log 出來大概會長這樣
{ $$typeof: Symbol(react.element), type: "div" key: null props: { children: { $$typeof: Symbol(react....</p></div><footer class=entry-footer><span title='2022-05-22 16:43:34 +0800 +0800'>May 22, 2022</span></footer><a class=entry-link aria-label="post link to React Fiber 初探" href=http://example.org/posts/react-fiber/></a></article><article class=post-entry><header class=entry-header><h2>Webpack Split Chunk</h2></header><div class=entry-content><p>雖然這個技術已經存在一段時間，但在現今大 Web 時代，若要增進網站的使用者經驗（UX）、效能、程式碼重複使用性……等等，依舊少不了 Code Splitting。
基本上此篇會 follow Webpack 官網上的 Code Splitting - Guild 並加上一些自己的想法來做介紹。
本篇適合給剛使用 Webpack 打包自己專案，並瞭解基本設定的開發者，如果你已熟悉它們的教程，那麼此篇其實可以考慮使用 cmd + w 或是 ctrl + w 進入彩蛋模式
什麼是 Code Splitting ? 從字面上來看 Code Splitting 即為將我們的 code（程式碼）給 Split（拆開），也就是說原本使用 Webpack 的打包出來的檔案，可能只有一個，但透過 Code Splitting 技術之後，可以將這一個檔案變成無數多個。
為什麼要這樣做？ 隨著需求日漸增加的專案，檔案以及資源只會越來越龐大，試想如果你一進到 SWAG Web App ，立刻就載入一份 50 MB 的 JS 檔案會是什麼情況？在網路不穩時可能會導致 Loading 長達 5 ~ 10 秒。
以 UX 來說，正常人類能夠感知到時間的差別為 0.1 秒，如果介於 0.1 秒 ~ 1 秒 之間會被使用者發現有東西正在載入或是運行，但完全可以接受，但如果到了 1 秒 ~ 5 秒 ，使用者會出現焦慮甚至懷疑程式出錯了，更不用提 5 秒之後，大部分使用者可能會選擇離開。...</p></div><footer class=entry-footer><span title='2019-01-30 10:22:50 +0800 +0800'>January 30, 2019</span></footer><a class=entry-link aria-label="post link to Webpack Split Chunk" href=http://example.org/posts/webpack-split-chunk/></a></article></main><footer class=footer><span>&copy; 2022 <a href=http://example.org/>Hakka Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>