<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>React Fiber 初探 | Hakka Blog</title><meta name=keywords content><meta name=description content="Fiber 是個重要但平常又不太需要瞭解的架構，這篇文章帶你了解大概的流程以及使用原因"><meta name=author content><link rel=canonical href=http://example.org/posts/react-fiber/><link crossorigin=anonymous href=/assets/css/stylesheet.min.3764877ba3a5494f5186c907876e4ed3f4d81cc8b5c752600f4d27d8cdfd1b45.css integrity="sha256-N2SHe6OlSU9RhskHh25O0/TYHMi1x1JgD00n2M39G0U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script> <link rel=icon href=http://example.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://example.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://example.org/favicon-32x32.png><link rel=apple-touch-icon href=http://example.org/apple-touch-icon.png><link rel=mask-icon href=http://example.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/custom.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="React Fiber 初探"><meta property="og:description" content="Fiber 是個重要但平常又不太需要瞭解的架構，這篇文章帶你了解大概的流程以及使用原因"><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/posts/react-fiber/"><meta property="og:image" content="http://example.org/posts/react-fiber/react_fiber_cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-22T16:43:34+08:00"><meta property="article:modified_time" content="2022-05-22T16:43:34+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://example.org/posts/react-fiber/react_fiber_cover.jpg"><meta name=twitter:title content="React Fiber 初探"><meta name=twitter:description content="Fiber 是個重要但平常又不太需要瞭解的架構，這篇文章帶你了解大概的流程以及使用原因"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://example.org/posts/"},{"@type":"ListItem","position":2,"name":"React Fiber 初探","item":"http://example.org/posts/react-fiber/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"React Fiber 初探","name":"React Fiber 初探","description":"Fiber 是個重要但平常又不太需要瞭解的架構，這篇文章帶你了解大概的流程以及使用原因","keywords":[],"articleBody":"React Fiber 廣義上可以代表整個新版架構，\n而狹義上 Fiber 只是一個 object，這個 object 是 reconciler 藉由 react element 作為模板建立出來。\n什麼是 React Element 平常寫 React Component 時，通常會在 render function 裡面使用 JSX 語法，而背後其實只是 JSX compiler 幫我們加入 React.createElement。\n例如：\nrender(){ return( \u003cdiv onClick={() =\u003e null}\u003e \u003cdiv\u003eHello Element\u003c/div\u003e \u003c/div\u003e ) } 會被轉成\nrender(){ return React.createElement( 'div', { onClick: myClick }, React.createElement('div', null, 'Hello Element'); ); } 如果直接將 createElement 的結果 console.log 出來大概會長這樣\n{ $$typeof: Symbol(react.element), type: \"div\" key: null props: { children: { $$typeof: Symbol(react.element), type: \"div\", key: null, props: { children: 'Hello Element' }, ref: null, ... }, onClick: myClick, } ref: null ... } 它們就是 react element ，那 Fiber object 呢？\nFiber Object 如何來的？ reconciler 會將 react element 作為參數，傳入 createFiberFromElement function 來產生 Fiber Object，而 Object 大概是長這樣。\n{ actualDuration: 0, actualStartTime: 3869.9000000953674, alternate: null, child: null, childLanes: 0, dependencies: null, elementType: \"div\", firstEffect: null, flags: 0, index: 0, key: null, lanes: 0, lastEffect: null, memoizedProps: null, memoizedState: null, mode: 9, nextEffect: null, pendingProps: null, ref: null, return: FiberNode, selfBaseDuration: 0, sibling: null, stateNode: div, tag: 5, treeBaseDuration: 0, type: \"div\", updateQueue: null, } 從這我們可以得知， react element 製造出 fiber object 。\nFiber Object 要做什麼？ ㄧ個 Fiber Object 通常被稱作 a unit of work ，它是最小的工作單位，理由是他裡面存了很多工作 資訊，準備交給 reconciler 來處理，而這些 work 都是可被 追蹤、 暫停 、 捨棄 、 安排。\nWhy 在開始進入 Fiber 架構前，我們應該先思考，為什麼 React 需要它以及它出現的原因？任何新的架構總是有他的目地或想要解決的問題， 而 react 真正想處理的地方則是 reconciler。\n什麼是 reconciler react 利用 tree 的資料結構，也可稱作 Virtual DOM，來代表各個 節點 的資料及狀態，\n這裡的節點可先當作是：網頁的 DOM（其他平台不一定是 DOM，例如： iOS 上)\nreconciler 會負責建立 tree（Virtual DOM），然後將其交給 renderer，請它用建立出來的 tree（Virtual DOM）畫出實際的介面給 User。\n除此之外，如果畫面需要更動（更新、刪除、插入……等）時，reconciler 會再建立出另一個 tree（Virtual DOM），並透過 diff 算法來互相比較，藉此得知哪些節點需要更新，最後在交給 renderer 畫出實際介面。\n什麼是 renderer 既然提到 renderer 再來簡單補充一下。\nrenderer 負責將 reconciler 建出的 tree（Virtual DOM） 畫出實際的介面給 User。\n以網頁上來說，則是配合 DOM 來處理。\n不同的環境會有不同的 renderer，iOS App 有自己的方式、Android App 也有自己的一套。\n而 react 在網頁上使用的 renderer lib 則是 react-dom ，這也是在寫 react 時， react 與 react-dom 需要分開 import 的原因。\n所以 reconciler 是有什麼問題？ 前面提到 reconciler 會負責建 tree，在 fiber 架構前，建立的方式是使用 遞迴，這會使得程式產生：call stack\ncall stack 是個不錯的演算邏輯，但遇到 react 畫面的處理上，會有個問題：\ncall stack 無法被中斷，必須等到 stack 清空，程式才能繼續往下執行。\n在 tree 很龐大的時候，call stack 會花太多時間執行，導致有些畫面的更新讓 User 感覺太慢卡卡的，尤其是 動畫 。\nBrowser 更新邏輯 理論上只要每次畫面更新的頻率在 16 毫秒(ms)以內，大部的人類不會察覺到差異（≥ 60 FPS)，所以 react 使用 requestIdleCallback api 來處理不重要的 work，requestIdleCallback 裡會告訴你 Main Thread 還剩多少時間可處理 work，變成 0ms 時就把 work 給暫停掉甚至丟掉，假如這個 work 很重要，那就會放到 requestAnimationFrame 內。\n怎麼解決？使用 Fiber 架構 在 Fiber 架構下的 reconciler， 使用 while 建立 Linked List tree ，while 的條件上除了確認是否還有 下一個 外，還會用個 flag： shouldYield() ，來確認 main thread 有沒有空。\nP.S. 這裡的 下一個 可能是 child、sibling\n// https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1126 // react source code while (nextUnitOfWork !== null \u0026\u0026 !shouldYield()) { nextUnitOfWork = performUnitOfWork(nextUnitOfWork); } 這樣只要 main thread 太忙，就把 shouldYield() 變 true，中斷 tree 的建立，\n直到 main thread 有空 shouldYield() 設回 false，再從中斷的地方繼續建 tree。\n建立 Fiber Tree 的大致流程 React component 呼叫 render() 時，會產生 react element tree，這個 tree 每次都是新的並不會重複使用，然而 reconciler 自己會在內部建立另一種 tree，稱為 Fiber Tree 。\n第一次 render() 時，reconciler 會將 react element tree 上的節點，使用 while 遍例，將其一一複製成 Fiber 節點， 形成一顆新的 Fiber Tree，這時這個 Tree 也叫做 Current Tree 。題外話，每一個 react element 的節點都是可以對應到產生出的 Fiber Node。\n下一次 render() 時（update 時)，reconciler 會建出另一顆新的 tree 叫做 Work in progress tree ，在建立的過程會順便把需要更新的 Node 標記 起來，這些被標記的 Node 會被串接成一條線性的 List ，稱為 Effect List （等等會用到）。\n當 Work in progress 樹建好之後，此時兩棵樹的 reference 對調（ Swap Tree )\nCurrent Tree → 成為 Work in progress Tree\nWork in progress Tree → 成為 Current Tree\n再下一次 render() ，Work in progress tree 不會再建立一次，會直接重複使用並且一樣找出需要更新的 Node 並標記起來形成 Effectt List ，如此一直重複下去。\nFiber Tree 的結構 前面提到 Fiber Object 上存了一些工作資訊，其中裡面有三個屬性代表著他們之間的關係。\nchild - 子節點 sibling - 鄰居節點 return - 父節點 假如 html 長這樣\n\u003cdiv\u003e \u003cp\u003e1\u003c/p\u003e \u003cp\u003e2\u003c/p\u003e \u003cp\u003e3\u003c/p\u003e \u003c/div\u003e 關係是\ndiv ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←← ↑ ↓ ↑ ↑ ↑ ↓ ↑ ↑ return ↑ ↓ child ↑ return ↑ return ↑ ↓ ↑ ↑ ↑ ↓ ↑ ↑ p(1) →→→→→→→→→→ p(2) →→→→→→→→→→ p(3) sibling sibling 比較要注意的是，這是一個 single child 的結構，如果有很多子節點，那只有第一個 child 會被當 child，其他變成 sibling。\n每一個節點都是一個 work，reconciler 處理的順序上是\n子節點 (child) 自己 sibling 大家可以參考這個連結的示意影片\n處理 Fiber Work 大致瞭解建樹的過程以及結構後，我們再來理解一下樹裡面的內容在做什麼，主要可以分為兩個步驟\nrender phase commit phase Render Phase 我第一次讀 fiber 的時候，不小心把 Render Phase 跟 react component 裡的 render() 搞混，大家要注意這是不同的。\nRender phase 的過程也稱為 work loop ，裡面執行 work 時是 非同步 的\n在稍前有貼過他的部分 source code\nfunction workLoop(isYieldy) { if (!isYieldy) { // Flush work without yielding while (nextUnitOfWork !== null) { nextUnitOfWork = performUnitOfWork(nextUnitOfWork); } } else { // Flush asynchronous work until the deadline runs out of time. while (nextUnitOfWork !== null \u0026\u0026 !shouldYield()) { nextUnitOfWork = performUnitOfWork(nextUnitOfWork); } } } work loop 開始處理會將第一個 Fiber Node 做為參數丟入 performUnitOfWork function，然後裡面會接著呼叫 beginWork ，假如還有 child Node，beginWork 會 return child，將其丟回 work loop 繼續執行 performUnitOfWork，如果沒有 child，則是執行 completeUnitOfWork 。\n// code is from https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react function completeUnitOfWork(workInProgress) { while (true) { let returnFiber = workInProgress.return; let siblingFiber = workInProgress.sibling; nextUnitOfWork = completeWork(workInProgress); if (siblingFiber !== null) { // If there is a sibling, return it // to perform work for this sibling return siblingFiber; } else if (returnFiber !== null) { // If there's no more work in this returnFiber, // continue the loop to complete the parent. workInProgress = returnFiber; continue; } else { // We've reached the root. return null; } } } function completeWork(workInProgress) { console.log(\"work completed for \" + workInProgress.name); return null; } completeUnitOfWork 會先呼叫 completeWork 來完成 自己 的 work，但除此之外還要確認。\n是否有 sibling Node，如果有就 return 回 beginWork，beginWork 如果有收到 sibling 則 return 回 work loop，接著重複上面的流程（performUnitOfWork）\n如果沒有 sibling 則確認是否有 return (parent)\n2 - 1 如果有，則把當前 work reference 變成 return，並且在下次 loop 去 complete 它\n2 - 2 如果沒有，代表已經到了 root 節點可以結束 work loop 了\n在 work loop 過程中最主要的任務，就是將有 side effect 的 Node 標記起來，並讓這些 Node 形成 effect list ，方法是透過 Fiber Object 上的 effectTag 、 nextEffect 屬性來紀錄。\nside effect 有可能是呼叫 lifecycle 、 setState 、 props 改變 、 手動更改 DOM 內容 ……等，這些都可能影響其他 component，因此無法在 非同步 的 render phase 完成。\nCommit 階段 首先到了這個階段，react 擁有三個東西\ncurrent tree 代表目前畫面的狀態樹，User 只會看到他的樣子\nworkInProgress tree render 階段產出的狀態樹，準備用來更新畫面\neffect list 從處理 workInProgress tree 中（也就是 render 階段），被標記出的 List。\nCommit 階段主要就是透過遍歷 effect list，將最新狀態更新到 tree 上，並把更新的 tree 變成 current tree，這樣就可以省去遍歷沒有 side effect 的 Node 的時間，要注意這個階段都是 同步 進行，並且是真實的改變畫面上的 DOM，此外如果 component 有 lifecycle 也是在這個階段被執行\ngetSnapshotBeforeUpdate → componentWillUnmount → 更新畫面 DOM → componentDidMount → componentDidUpdate （細節可參考此文的 commit phase)\n結論 Fiber 架構的好處在於使用 非同步 的方式處理每個 work，因此當瀏覽器太忙有些事要做的時候，可以將 work 隨時暫停或是丟掉，而我自己認為實作的關鍵在於將 遞迴 處理樹的部分，轉為使用 while 並且搭配 requestIdleCallback 來確認剩餘時間，當然裡面還有做了很多細節處理及架構優化。\n想了解更多細節可以參考以下的資料\nReference: Inside Fiber: in-depth overview of the new reconciliation algorithm in React The how and why on React’s usage of linked list in Fiber to walk the component’s tree React Doc - Reconciliation React 開發者一定要知道的底層機制 — React Fiber Reconciler What Is React Fiber? React.js Deep Dive #2 Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 SMOOSHCAST: React Fiber Deep Dive with Dan Abramov ","wordCount":"1005","inLanguage":"en","datePublished":"2022-05-22T16:43:34+08:00","dateModified":"2022-05-22T16:43:34+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.org/posts/react-fiber/"},"publisher":{"@type":"Organization","name":"Hakka Blog","logo":{"@type":"ImageObject","url":"http://example.org/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://example.org/ accesskey=h title="Hakka Blog (Alt + H)">Hakka Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>React Fiber 初探</h1><div class=post-description>Fiber 是個重要但平常又不太需要瞭解的架構，這篇文章帶你了解大概的流程以及使用原因</div><div class=post-meta><span title='2022-05-22 16:43:34 +0800 +0800'>May 22, 2022</span></div></header><div class=post-content><p>React Fiber 廣義上可以代表整個新版架構，</p><p>而狹義上 Fiber 只是一個 <code>object</code>，這個 object 是 reconciler 藉由 react element 作為模板建立出來。</p><h3 id=什麼是-react-element>什麼是 React Element<a hidden class=anchor aria-hidden=true href=#什麼是-react-element>#</a></h3><p>平常寫 React Component 時，通常會在 render function 裡面使用 JSX 語法，而背後其實只是 JSX compiler 幫我們加入 <code>React.createElement</code>。</p><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>  <span style=color:#a6e22e>render</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>(
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>div</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#66d9ef>null</span>}<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>div</span><span style=color:#f92672>&gt;</span><span style=color:#a6e22e>Hello</span> <span style=color:#a6e22e>Element</span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/div&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/div&gt;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>會被轉成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>  <span style=color:#a6e22e>render</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>createElement</span>(
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;div&#39;</span>,
</span></span><span style=display:flex><span>      { <span style=color:#a6e22e>onClick</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>myClick</span> },
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#39;div&#39;</span>, <span style=color:#66d9ef>null</span>, <span style=color:#e6db74>&#39;Hello Element&#39;</span>);
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>如果直接將 createElement 的結果 console.log 出來大概會長這樣</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>$$typeof</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Symbol</span>(<span style=color:#a6e22e>react</span>.<span style=color:#a6e22e>element</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;div&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>key</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>props</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>children</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>$$typeof</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Symbol</span>(<span style=color:#a6e22e>react</span>.<span style=color:#a6e22e>element</span>),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;div&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>key</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>props</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>children</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Hello Element&#39;</span> },
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ref</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>onClick</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>myClick</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ref</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>它們就是 react element ，那 Fiber object 呢？</p><h3 id=fiber-object-如何來的>Fiber Object 如何來的？<a hidden class=anchor aria-hidden=true href=#fiber-object-如何來的>#</a></h3><p>reconciler 會將 react element 作為參數，傳入 <a href=https://github.com/facebook/react/blob/ce13860281f833de8a3296b7a3dad9caced102e9/packages/react-reconciler/src/ReactFiber.new.js#L604><code>createFiberFromElement</code></a> function 來產生 Fiber Object，而 Object 大概是長這樣。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>actualDuration</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>actualStartTime</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3869.9000000953674</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>alternate</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>child</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>childLanes</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dependencies</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>elementType</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;div&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>firstEffect</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>flags</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>index</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>key</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lanes</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lastEffect</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memoizedProps</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memoizedState</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mode</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>9</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>nextEffect</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pendingProps</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ref</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>FiberNode</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>selfBaseDuration</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sibling</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stateNode</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>div</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>tag</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>treeBaseDuration</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;div&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>updateQueue</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>從這我們可以得知， react element 製造出 fiber object 。</p><h3 id=fiber-object-要做什麼>Fiber Object 要做什麼？<a hidden class=anchor aria-hidden=true href=#fiber-object-要做什麼>#</a></h3><p>ㄧ個 Fiber Object 通常被稱作 a unit of work ，它是最小的工作單位，理由是他裡面存了很多工作 <code>資訊</code>，準備交給 reconciler 來處理，而這些 work 都是可被 <code>追蹤</code>、 <code>暫停</code> 、 <code>捨棄</code> 、 <code>安排</code>。</p><h3 id=why>Why<a hidden class=anchor aria-hidden=true href=#why>#</a></h3><p>在開始進入 Fiber 架構前，我們應該先思考，為什麼 React 需要它以及它出現的原因？任何新的架構總是有他的目地或想要解決的問題，
而 react 真正想處理的地方則是 <code>reconciler</code>。</p><h3 id=什麼是-reconciler>什麼是 reconciler<a hidden class=anchor aria-hidden=true href=#什麼是-reconciler>#</a></h3><p>react 利用 tree 的資料結構，也可稱作 Virtual DOM，來代表各個 <code>節點</code> 的資料及狀態，</p><p>這裡的節點可先當作是：網頁的 DOM（其他平台不一定是 DOM，例如： iOS 上)</p><p>reconciler 會負責建立 tree（Virtual DOM），然後將其交給 renderer，請它用建立出來的 tree（Virtual DOM）畫出實際的介面給 User。</p><p>除此之外，如果畫面需要更動（更新、刪除、插入&mldr;&mldr;等）時，reconciler 會再建立出另一個 tree（Virtual DOM），並透過 <code>diff</code> 算法來互相比較，藉此得知哪些節點需要更新，最後在交給 renderer 畫出實際介面。</p><h3 id=什麼是-renderer>什麼是 renderer<a hidden class=anchor aria-hidden=true href=#什麼是-renderer>#</a></h3><p>既然提到 renderer 再來簡單補充一下。</p><p>renderer 負責將 reconciler 建出的 tree（Virtual DOM） 畫出實際的介面給 User。</p><p>以網頁上來說，則是配合 DOM 來處理。</p><p>不同的環境會有不同的 renderer，iOS App 有自己的方式、Android App 也有自己的一套。</p><p>而 react 在網頁上使用的 renderer lib 則是 <code>react-dom</code> ，這也是在寫 react 時， <code>react</code> 與 <code>react-dom</code> 需要分開 import 的原因。</p><h3 id=所以-reconciler-是有什麼問題>所以 reconciler 是有什麼問題？<a hidden class=anchor aria-hidden=true href=#所以-reconciler-是有什麼問題>#</a></h3><p>前面提到 reconciler 會負責建 tree，在 fiber 架構前，建立的方式是使用 <code>遞迴</code>，這會使得程式產生：<code>call stack</code></p><p>call stack 是個不錯的演算邏輯，但遇到 react 畫面的處理上，會有個問題：</p><p><code>call stack 無法被中斷</code>，必須等到 stack 清空，程式才能繼續往下執行。</p><p>在 tree 很龐大的時候，call stack 會花太多時間執行，導致有些畫面的更新讓 User 感覺太慢卡卡的，尤其是 <code>動畫</code> 。</p><h3 id=browser-更新邏輯>Browser 更新邏輯<a hidden class=anchor aria-hidden=true href=#browser-更新邏輯>#</a></h3><p>理論上只要每次畫面更新的頻率在 16 毫秒(ms)以內，大部的人類不會察覺到差異（≥ 60 FPS)，所以 react 使用 <code>requestIdleCallback</code> api 來處理不重要的 work，requestIdleCallback 裡會告訴你 Main Thread 還剩多少時間可處理 work，變成 0ms 時就把 work 給暫停掉甚至丟掉，假如這個 work 很重要，那就會放到 <code>requestAnimationFrame</code> 內。</p><h3 id=怎麼解決使用-fiber-架構>怎麼解決？使用 Fiber 架構<a hidden class=anchor aria-hidden=true href=#怎麼解決使用-fiber-架構>#</a></h3><p>在 Fiber 架構下的 reconciler， 使用 <code>while</code> 建立 <code>Linked List tree</code> ，while 的條件上除了確認是否還有 <code>下一個</code> 外，還會用個 flag： <code>shouldYield()</code> ，來確認 main thread 有沒有空。</p><blockquote><p>P.S. 這裡的 下一個 可能是 child、sibling</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js?source=post_page---------------------------#L1126
</span></span></span><span style=display:flex><span><span style=color:#75715e>// react source code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>nextUnitOfWork</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>shouldYield</span>()) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>nextUnitOfWork</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>performUnitOfWork</span>(<span style=color:#a6e22e>nextUnitOfWork</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>這樣只要 main thread 太忙，就把 <code>shouldYield()</code> 變 true，中斷 tree 的建立，</p><p>直到 main thread 有空 <code>shouldYield()</code> 設回 false，再從中斷的地方繼續建 tree。</p><h3 id=建立-fiber-tree-的大致流程>建立 Fiber Tree 的大致流程<a hidden class=anchor aria-hidden=true href=#建立-fiber-tree-的大致流程>#</a></h3><p>React component 呼叫 <code>render()</code> 時，會產生 react element tree，這個 tree 每次都是新的並不會重複使用，然而 reconciler 自己會在內部建立另一種 tree，稱為 <code>Fiber Tree</code> 。</p><p>第一次 <code>render()</code> 時，reconciler 會將 react element tree 上的節點，使用 <code>while</code> 遍例，將其一一複製成 Fiber 節點， 形成一顆新的 Fiber Tree，這時這個 Tree 也叫做 <code>Current Tree</code> 。題外話，每一個 react element 的節點都是可以對應到產生出的 Fiber Node。</p><p>下一次 <code>render()</code> 時（update 時)，reconciler 會建出另一顆新的 tree 叫做 <code>Work in progress tree</code> ，在建立的過程會順便把需要更新的 Node <code>標記</code> 起來，這些被標記的 Node 會被串接成一條線性的 <code>List</code> ，稱為 <code>Effect List</code> （等等會用到）。</p><p>當 Work in progress 樹建好之後，此時兩棵樹的 reference 對調（ <code>Swap Tree</code> )</p><p>Current Tree → 成為 Work in progress Tree</p><p>Work in progress Tree → 成為 Current Tree</p><p>再下一次 render() ，Work in progress tree 不會再建立一次，會直接重複使用並且一樣找出需要更新的 Node 並標記起來形成 Effectt List ，如此一直重複下去。</p><h3 id=fiber-tree-的結構>Fiber Tree 的結構<a hidden class=anchor aria-hidden=true href=#fiber-tree-的結構>#</a></h3><p>前面提到 Fiber Object 上存了一些工作資訊，其中裡面有三個屬性代表著他們之間的關係。</p><ul><li>child - 子節點</li><li>sibling - 鄰居節點</li><li>return - 父節點</li></ul><p>假如 html 長這樣</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>p</span>&gt;1&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>p</span>&gt;2&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>p</span>&gt;3&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><p>關係是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>
</span></span><span style=display:flex><span>         div ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←
</span></span><span style=display:flex><span>        ↑   ↓             ↑               ↑
</span></span><span style=display:flex><span>        ↑   ↓             ↑               ↑
</span></span><span style=display:flex><span> return ↑   ↓ child       ↑ return        ↑ return
</span></span><span style=display:flex><span>        ↑   ↓             ↑               ↑
</span></span><span style=display:flex><span>        ↑   ↓             ↑               ↑
</span></span><span style=display:flex><span>         p(1) →→→→→→→→→→ p(2) →→→→→→→→→→ p(3)
</span></span><span style=display:flex><span>                sibling         sibling
</span></span></code></pre></div><p>比較要注意的是，這是一個 single child 的結構，如果有很多子節點，那只有第一個 child 會被當 child，其他變成 sibling。</p><p>每一個節點都是一個 work，reconciler 處理的順序上是</p><ol><li>子節點 (child)</li><li>自己</li><li>sibling</li></ol><p>大家可以參考這個連結的示意<a href=https://vimeo.com/302222454>影片</a></p><h3 id=處理-fiber-work>處理 Fiber Work<a hidden class=anchor aria-hidden=true href=#處理-fiber-work>#</a></h3><p>大致瞭解建樹的過程以及結構後，我們再來理解一下樹裡面的內容在做什麼，主要可以分為兩個步驟</p><ol><li>render phase</li><li>commit phase</li></ol><h3 id=render-phase>Render Phase<a hidden class=anchor aria-hidden=true href=#render-phase>#</a></h3><p>我第一次讀 fiber 的時候，不小心把 Render Phase 跟 react component 裡的 <code>render()</code> 搞混，大家要注意這是不同的。</p><p>Render phase 的過程也稱為 <code>work loop</code> ，裡面執行 work 時是 <code>非同步</code> 的</p><p>在稍前有貼過他的部分 source code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>workLoop</span>(<span style=color:#a6e22e>isYieldy</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>isYieldy</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Flush work without yielding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>nextUnitOfWork</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>nextUnitOfWork</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>performUnitOfWork</span>(<span style=color:#a6e22e>nextUnitOfWork</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Flush asynchronous work until the deadline runs out of time.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>nextUnitOfWork</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>shouldYield</span>()) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>nextUnitOfWork</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>performUnitOfWork</span>(<span style=color:#a6e22e>nextUnitOfWork</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>work loop 開始處理會將第一個 Fiber Node 做為參數丟入 <code>performUnitOfWork</code> function，然後裡面會接著呼叫 <code>beginWork</code> ，假如還有 child Node，beginWork 會 return child，將其丟回 work loop 繼續執行 performUnitOfWork，如果沒有 child，則是執行 <code>completeUnitOfWork</code> 。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>// code is from https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>completeUnitOfWork</span>(<span style=color:#a6e22e>workInProgress</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>returnFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>workInProgress</span>.<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>siblingFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>workInProgress</span>.<span style=color:#a6e22e>sibling</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>nextUnitOfWork</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>completeWork</span>(<span style=color:#a6e22e>workInProgress</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>siblingFiber</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// If there is a sibling, return it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// to perform work for this sibling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>siblingFiber</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>returnFiber</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// If there&#39;s no more work in this returnFiber,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// continue the loop to complete the parent.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>workInProgress</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>returnFiber</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// We&#39;ve reached the root.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>completeWork</span>(<span style=color:#a6e22e>workInProgress</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;work completed for &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>workInProgress</span>.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>completeUnitOfWork 會先呼叫 <code>completeWork</code> 來完成 <code>自己</code> 的 work，但除此之外還要確認。</p><ol><li><p>是否有 <code>sibling</code> Node，如果有就 return 回 beginWork，beginWork 如果有收到 sibling 則 return 回 work loop，接著重複上面的流程（performUnitOfWork）</p></li><li><p>如果沒有 sibling 則確認是否有 return (parent)</p><p>2 - 1 如果有，則把當前 work reference 變成 return，並且在下次 loop 去 complete 它</p><p>2 - 2 如果沒有，代表已經到了 root 節點可以結束 work loop 了</p></li></ol><p>在 work loop 過程中最主要的任務，就是將有 <code>side effect</code> 的 Node 標記起來，並讓這些 Node 形成 <code>effect list</code> ，方法是透過 Fiber Object 上的 <code>effectTag</code> 、 <code>nextEffect</code> 屬性來紀錄。</p><p>side effect 有可能是呼叫 <code>lifecycle</code> 、 <code>setState</code> 、 <code>props 改變</code> 、 <code>手動更改 DOM 內容</code> &mldr;&mldr;等，這些都可能影響其他 component，因此無法在 <code>非同步</code> 的 render phase 完成。</p><h3 id=commit-階段>Commit 階段<a hidden class=anchor aria-hidden=true href=#commit-階段>#</a></h3><p>首先到了這個階段，react 擁有三個東西</p><ol><li>current tree</li></ol><p>代表目前畫面的狀態樹，User 只會看到他的樣子</p><ol><li>workInProgress tree</li></ol><p>render 階段產出的狀態樹，準備用來更新畫面</p><ol><li>effect list</li></ol><p>從處理 workInProgress tree 中（也就是 render 階段），被標記出的 List。</p><p>Commit 階段主要就是透過遍歷 effect list，將最新狀態更新到 tree 上，並把更新的 tree 變成 current tree，這樣就可以省去遍歷沒有 side effect 的 Node 的時間，要注意這個階段都是 <code>同步</code> 進行，並且是真實的改變畫面上的 DOM，此外如果 component 有 lifecycle 也是在這個階段被執行</p><p>getSnapshotBeforeUpdate → componentWillUnmount → <code>更新畫面 DOM</code> → componentDidMount → componentDidUpdate （細節可參考此文的 <a href=https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react>commit phase</a>)</p><h3 id=結論>結論<a hidden class=anchor aria-hidden=true href=#結論>#</a></h3><p>Fiber 架構的好處在於使用 <code>非同步</code> 的方式處理每個 <code>work</code>，因此當瀏覽器太忙有些事要做的時候，可以將 work 隨時暫停或是丟掉，而我自己認為實作的關鍵在於將 <code>遞迴</code> 處理樹的部分，轉為使用 <code>while</code> 並且搭配 requestIdleCallback 來確認剩餘時間，當然裡面還有做了很多細節處理及架構優化。</p><p>想了解更多細節可以參考以下的資料</p><h3 id=reference>Reference:<a hidden class=anchor aria-hidden=true href=#reference>#</a></h3><ul><li><a href=https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react>Inside Fiber: in-depth overview of the new reconciliation algorithm in React</a></li><li><a href=https://indepth.dev/posts/1007/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree>The how and why on React’s usage of linked list in Fiber to walk the component’s tree</a></li><li><a href=https://reactjs.org/docs/reconciliation.html#gatsby-focus-wrapper>React Doc - Reconciliation</a></li><li><a href=https://medium.com/starbugs/react-%E9%96%8B%E7%99%BC%E8%80%85%E4%B8%80%E5%AE%9A%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%BA%95%E5%B1%A4%E6%9E%B6%E6%A7%8B-react-fiber-c3ccd3b047a1>React 開發者一定要知道的底層機制 — React Fiber Reconciler</a></li><li><a href="https://www.youtube.com/watch?v=0ympFIwQFJw">What Is React Fiber? React.js Deep Dive #2</a></li><li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017</a></li><li><a href="https://www.youtube.com/watch?v=aS41Y_eyNrU">SMOOSHCAST: React Fiber Deep Dive with Dan Abramov</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://example.org/>Hakka Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>