<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Webpack Split Chunk | Hakka Blog</title><meta name=keywords content><meta name=description content="雖然這個技術已經存在一段時間，但在現今大 Web 時代，若要增進網站的使用者經驗（UX）、效能、程式碼重複使用性……等等，依舊少不了 Code Splitting。
基本上此篇會 follow Webpack 官網上的 Code Splitting - Guild 並加上一些自己的想法來做介紹。
本篇適合給剛使用 Webpack 打包自己專案，並瞭解基本設定的開發者，如果你已熟悉它們的教程，那麼此篇其實可以考慮使用 cmd + w 或是 ctrl + w 進入彩蛋模式
什麼是 Code Splitting ? 從字面上來看 Code Splitting 即為將我們的 code（程式碼）給 Split（拆開），也就是說原本使用 Webpack 的打包出來的檔案，可能只有一個，但透過 Code Splitting 技術之後，可以將這一個檔案變成無數多個。
為什麼要這樣做？ 隨著需求日漸增加的專案，檔案以及資源只會越來越龐大，試想如果你一進到 SWAG Web App ，立刻就載入一份 50 MB 的 JS 檔案會是什麼情況？在網路不穩時可能會導致 Loading 長達 5 ~ 10 秒。
以 UX 來說，正常人類能夠感知到時間的差別為 0.1 秒，如果介於 0.1 秒 ~ 1 秒 之間會被使用者發現有東西正在載入或是運行，但完全可以接受，但如果到了 1 秒 ~ 5 秒 ，使用者會出現焦慮甚至懷疑程式出錯了，更不用提 5 秒之後，大部分使用者可能會選擇離開。"><meta name=author content><link rel=canonical href=https://curt6815463.github.io/hakka-dev-blog/posts/webpack-split-chunk/><link crossorigin=anonymous href=/hakka-dev-blog/assets/css/stylesheet.min.3764877ba3a5494f5186c907876e4ed3f4d81cc8b5c752600f4d27d8cdfd1b45.css integrity="sha256-N2SHe6OlSU9RhskHh25O0/TYHMi1x1JgD00n2M39G0U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/hakka-dev-blog/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script> <link rel=icon href=https://curt6815463.github.io/hakka-dev-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://curt6815463.github.io/hakka-dev-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://curt6815463.github.io/hakka-dev-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://curt6815463.github.io/hakka-dev-blog/apple-touch-icon.png><link rel=mask-icon href=https://curt6815463.github.io/hakka-dev-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/custom.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Webpack Split Chunk"><meta property="og:description" content="雖然這個技術已經存在一段時間，但在現今大 Web 時代，若要增進網站的使用者經驗（UX）、效能、程式碼重複使用性……等等，依舊少不了 Code Splitting。
基本上此篇會 follow Webpack 官網上的 Code Splitting - Guild 並加上一些自己的想法來做介紹。
本篇適合給剛使用 Webpack 打包自己專案，並瞭解基本設定的開發者，如果你已熟悉它們的教程，那麼此篇其實可以考慮使用 cmd + w 或是 ctrl + w 進入彩蛋模式
什麼是 Code Splitting ? 從字面上來看 Code Splitting 即為將我們的 code（程式碼）給 Split（拆開），也就是說原本使用 Webpack 的打包出來的檔案，可能只有一個，但透過 Code Splitting 技術之後，可以將這一個檔案變成無數多個。
為什麼要這樣做？ 隨著需求日漸增加的專案，檔案以及資源只會越來越龐大，試想如果你一進到 SWAG Web App ，立刻就載入一份 50 MB 的 JS 檔案會是什麼情況？在網路不穩時可能會導致 Loading 長達 5 ~ 10 秒。
以 UX 來說，正常人類能夠感知到時間的差別為 0.1 秒，如果介於 0.1 秒 ~ 1 秒 之間會被使用者發現有東西正在載入或是運行，但完全可以接受，但如果到了 1 秒 ~ 5 秒 ，使用者會出現焦慮甚至懷疑程式出錯了，更不用提 5 秒之後，大部分使用者可能會選擇離開。"><meta property="og:type" content="article"><meta property="og:url" content="https://curt6815463.github.io/hakka-dev-blog/posts/webpack-split-chunk/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-01-30T10:22:50+08:00"><meta property="article:modified_time" content="2019-01-30T10:22:50+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Webpack Split Chunk"><meta name=twitter:description content="雖然這個技術已經存在一段時間，但在現今大 Web 時代，若要增進網站的使用者經驗（UX）、效能、程式碼重複使用性……等等，依舊少不了 Code Splitting。
基本上此篇會 follow Webpack 官網上的 Code Splitting - Guild 並加上一些自己的想法來做介紹。
本篇適合給剛使用 Webpack 打包自己專案，並瞭解基本設定的開發者，如果你已熟悉它們的教程，那麼此篇其實可以考慮使用 cmd + w 或是 ctrl + w 進入彩蛋模式
什麼是 Code Splitting ? 從字面上來看 Code Splitting 即為將我們的 code（程式碼）給 Split（拆開），也就是說原本使用 Webpack 的打包出來的檔案，可能只有一個，但透過 Code Splitting 技術之後，可以將這一個檔案變成無數多個。
為什麼要這樣做？ 隨著需求日漸增加的專案，檔案以及資源只會越來越龐大，試想如果你一進到 SWAG Web App ，立刻就載入一份 50 MB 的 JS 檔案會是什麼情況？在網路不穩時可能會導致 Loading 長達 5 ~ 10 秒。
以 UX 來說，正常人類能夠感知到時間的差別為 0.1 秒，如果介於 0.1 秒 ~ 1 秒 之間會被使用者發現有東西正在載入或是運行，但完全可以接受，但如果到了 1 秒 ~ 5 秒 ，使用者會出現焦慮甚至懷疑程式出錯了，更不用提 5 秒之後，大部分使用者可能會選擇離開。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://curt6815463.github.io/hakka-dev-blog/posts/"},{"@type":"ListItem","position":2,"name":"Webpack Split Chunk","item":"https://curt6815463.github.io/hakka-dev-blog/posts/webpack-split-chunk/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Webpack Split Chunk","name":"Webpack Split Chunk","description":"雖然這個技術已經存在一段時間，但在現今大 Web 時代，若要增進網站的使用者經驗（UX）、效能、程式碼重複使用性……等等，依舊少不了 Code Splitting。\n基本上此篇會 follow Webpack 官網上的 Code Splitting - Guild 並加上一些自己的想法來做介紹。\n本篇適合給剛使用 Webpack 打包自己專案，並瞭解基本設定的開發者，如果你已熟悉它們的教程，那麼此篇其實可以考慮使用 cmd + w 或是 ctrl + w 進入彩蛋模式\n什麼是 Code Splitting ? 從字面上來看 Code Splitting 即為將我們的 code（程式碼）給 Split（拆開），也就是說原本使用 Webpack 的打包出來的檔案，可能只有一個，但透過 Code Splitting 技術之後，可以將這一個檔案變成無數多個。\n為什麼要這樣做？ 隨著需求日漸增加的專案，檔案以及資源只會越來越龐大，試想如果你一進到 SWAG Web App ，立刻就載入一份 50 MB 的 JS 檔案會是什麼情況？在網路不穩時可能會導致 Loading 長達 5 ~ 10 秒。\n以 UX 來說，正常人類能夠感知到時間的差別為 0.1 秒，如果介於 0.1 秒 ~ 1 秒 之間會被使用者發現有東西正在載入或是運行，但完全可以接受，但如果到了 1 秒 ~ 5 秒 ，使用者會出現焦慮甚至懷疑程式出錯了，更不用提 5 秒之後，大部分使用者可能會選擇離開。","keywords":[],"articleBody":"雖然這個技術已經存在一段時間，但在現今大 Web 時代，若要增進網站的使用者經驗（UX）、效能、程式碼重複使用性……等等，依舊少不了 Code Splitting。\n基本上此篇會 follow Webpack 官網上的 Code Splitting - Guild 並加上一些自己的想法來做介紹。\n本篇適合給剛使用 Webpack 打包自己專案，並瞭解基本設定的開發者，如果你已熟悉它們的教程，那麼此篇其實可以考慮使用 cmd + w 或是 ctrl + w 進入彩蛋模式\n什麼是 Code Splitting ? 從字面上來看 Code Splitting 即為將我們的 code（程式碼）給 Split（拆開），也就是說原本使用 Webpack 的打包出來的檔案，可能只有一個，但透過 Code Splitting 技術之後，可以將這一個檔案變成無數多個。\n為什麼要這樣做？ 隨著需求日漸增加的專案，檔案以及資源只會越來越龐大，試想如果你一進到 SWAG Web App ，立刻就載入一份 50 MB 的 JS 檔案會是什麼情況？在網路不穩時可能會導致 Loading 長達 5 ~ 10 秒。\n以 UX 來說，正常人類能夠感知到時間的差別為 0.1 秒，如果介於 0.1 秒 ~ 1 秒 之間會被使用者發現有東西正在載入或是運行，但完全可以接受，但如果到了 1 秒 ~ 5 秒 ，使用者會出現焦慮甚至懷疑程式出錯了，更不用提 5 秒之後，大部分使用者可能會選擇離開。\n事實上使用者到 SWAG Web App 時，並不需要所有 JS 程式碼都一次載進來，也就是如果他到了這個頁面 https://app.swag.live 我們沒有必要將 https://app.swag.live/discover 的資源也載入進去。\n需要什麼才拿什麼，就能有效降低 Loading 平均時間\n實作 前置作業 首先創建一包資料夾、產生 package.json 並安裝 webpack、webpack-cli 及 lodash （lodash 是為了測試 code splitting 用的第三方套件）PS: Npm 6.4, Webpack 4.29\nmkdir codesplitting cd codesplitting npm init -y npm i webpack webpack-cli lodash 第一式：Mutiple Entry const path = require(\"path\"); module.exports = { entry: { page1: \"./src/page1.js\", page2: \"./src/page2.js\", }, mode: \"development\", output: { path: path.resolve(__dirname, \"dist\"), filename: \"[name].bundle.js\", }, }; 新增 src/page1.js，並輸入\nconsole.log(\"this is page1\"); 新增 src/page2.js，並輸入\nconsole.log(\"this is page2\"); 接著在 command line 執行 npx webpack 就可以看到專案下多了一個 dist 資料夾，裡面放著打包好的檔案 page1.bundle.js \u0026\u0026 page2.bundle.js\n將它門打開來看可能發現一堆看不懂的 code，不過分別搜尋 console.log('this is page1') \u0026\u0026 console.log('this is page2') 確實包含在裡面。\nOK！這樣已經完成最初階的 CodeSplitting，我們可以透過前端 route 的手法讓使用者者切到 /page1 的時候載入 page1.bundle.js 就好， /page2 則是 page2.bundle.js\n那如果讓 page1、2 一起使用 lodash 會發生什麼事？\n// /src/page1.js import lodash from \"lodash\"; console.log(\"this is page1\"); // /src/page2.js import lodash from \"lodash\"; console.log(\"this is page2\"); 一樣使用 npx webpack 指令後會發現 page1、2.bundle.js 都變成一樣肥。\n為了方便驗證，我們來使用 webpack-bundle-analyzer plugin。\nnpm install — save-dev webpack-bundle-analyzer webpack.config.js 改成 const path = require(\"path\"); const BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin; module.exports = { entry: { page1: \"./src/page1.js\", page2: \"./src/page2.js\", }, mode: \"development\", output: { path: path.resolve(__dirname, \"dist\"), filename: \"[name].bundle.js\", }, plugins: [new BundleAnalyzerPlugin()], }; 再執行一次 npx webpack 時，可以在 http://127.0.0.1:8888 看到它分析的結果\n這樣是非常不合理，應該把 lodash.js 獨立成另外一個檔案（chunk)，讓 page1、2 共同使用\n第二式：SplitChunksPlugin 為了避免同樣的 module 被重複打包，可以使用 webpack 提供的套件 SplitChunksPlugin，原本叫做 CommonsChunkPlugin，但在後來的版本被納入內建使用，只要在 optimization.splitChunks 設定即可\n修改一下 webpack.config.js\nconst path = require(\"path\"); const BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin; module.exports = { entry: { page1: \"./src/page1.js\", page2: \"./src/page2.js\", }, mode: \"development\", output: { path: path.resolve(__dirname, \"dist\"), filename: \"[name].bundle.js\", }, optimization: { splitChunks: { chunks: \"all\", }, }, plugins: [new BundleAnalyzerPlugin()], }; 輸入 npx webpack\n可以看到 lodash 被獨立成單獨的檔案\n~Async chunks VS Non-async chunks~\n如果將 chunks: 'all' 改成 chunks: 'async' 再執行 npx webpack ，會發現結果又回到原本的樣子，為什麼呢？\n因為使用 mutiple entry 載入的檔案會被歸類為 Non-async chunk，設定 chunk:'async' 後，SplitChunksPlugin 只會對 Async chunk 進行 Code-Splitting 的優化\n那麼怎樣算是 Async chunk 呢？\n第三式：Dynamic Imports 只要使用 import(...) 載入的檔案，webpack 會自動將它打包成一個獨立檔案，同時也被視為 Async chunk\n它跟 mutiple entry 有相同的效果，但是卻可以在一個檔案內用 dynamic 方式 import 多個檔案，我們來修改範例\n在 src/ 底下新增 index.js 檔案\nimport(\"./page1.js\"); import(\"./page2.js\"); console.log(\"this is index.js\"); 修改 webpack.config.js\nentry: \"./src/index.js\"; 執行 npx webpack\n可以看到 page1、2 都被個別獨立成一個檔案，而且他們之間共用的套件（lodash) 也被獨立成例外一個檔名。\n如何使用 React 簡單辦到 這裡貼上 React 文件上 Route 與 Code Splitting 的範例\n簡單地來說，所有 component 都使用 import(…) 載入並掛上 Route 物件，這樣一來就可以根據不同頁面載入其所需的資源（ js 檔案）\n總結 讀完以上簡介後可以發現設定 webpack code-splitting 並不難，只要簡單幾步就可以很有效的優化專案載入效能\n然而 SplitChunks 裡面也有其他設定可以讓你將檔案切的更碎，此時就需評估是否有這個必要，會不會造成過多的 loading 反而影響了使用者體驗？\nReference\nCode-Splitting - React Webpack 4 — Mysterious SplitChunks Plugin SplitChunksPlugin | webpack Code Splitting | webpack\n","wordCount":"446","inLanguage":"en","datePublished":"2019-01-30T10:22:50+08:00","dateModified":"2019-01-30T10:22:50+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://curt6815463.github.io/hakka-dev-blog/posts/webpack-split-chunk/"},"publisher":{"@type":"Organization","name":"Hakka Blog","logo":{"@type":"ImageObject","url":"https://curt6815463.github.io/hakka-dev-blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://curt6815463.github.io/hakka-dev-blog/ accesskey=h title="Hakka Blog (Alt + H)">Hakka Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Webpack Split Chunk</h1><div class=post-meta><span title='2019-01-30 10:22:50 +0800 +0800'>January 30, 2019</span></div></header><div class=post-content><p>雖然這個技術已經存在一段時間，但在現今大 Web 時代，若要增進網站的使用者經驗（UX）、效能、程式碼重複使用性……等等，依舊少不了 Code Splitting。</p><p>基本上此篇會 follow Webpack 官網上的 <a href=https://webpack.js.org/guides/code-splitting/>Code Splitting - Guild</a> 並加上一些自己的想法來做介紹。</p><p>本篇適合給剛使用 Webpack 打包自己專案，並瞭解基本設定的開發者，如果你已熟悉它們的教程，那麼此篇其實可以考慮使用 cmd + w 或是 ctrl + w 進入彩蛋模式</p><h3 id=什麼是-code-splitting->什麼是 Code Splitting ?<a hidden class=anchor aria-hidden=true href=#什麼是-code-splitting->#</a></h3><p>從字面上來看 Code Splitting 即為將我們的 code（程式碼）給 Split（拆開），也就是說原本使用 Webpack 的打包出來的檔案，可能只有一個，但透過 Code Splitting 技術之後，可以將這一個檔案變成無數多個。</p><h3 id=為什麼要這樣做>為什麼要這樣做？<a hidden class=anchor aria-hidden=true href=#為什麼要這樣做>#</a></h3><p>隨著需求日漸增加的專案，檔案以及資源只會越來越龐大，試想如果你一進到 SWAG Web App ，立刻就載入一份 50 MB 的 JS 檔案會是什麼情況？在網路不穩時可能會導致 Loading 長達 5 ~ 10 秒。</p><p>以 UX 來說，正常人類能夠感知到時間的差別為 <code>0.1 秒</code>，如果介於 <code>0.1 秒 ~ 1 秒</code> 之間會被使用者發現有東西正在載入或是運行，但完全可以接受，但如果到了 <code>1 秒 ~ 5 秒</code> ，使用者會出現焦慮甚至懷疑程式出錯了，更不用提 5 秒之後，大部分使用者可能會選擇離開。</p><p>事實上使用者到 SWAG Web App 時，並不需要所有 JS 程式碼都一次載進來，也就是如果他到了這個頁面 <a href=https://app.swag.live>https://app.swag.live</a> 我們沒有必要將 <a href=https://app.swag.live/discover>https://app.swag.live/discover</a> 的資源也載入進去。</p><p>需要什麼才拿什麼，就能有效降低 Loading 平均時間</p><h2 id=實作>實作<a hidden class=anchor aria-hidden=true href=#實作>#</a></h2><h3 id=前置作業>前置作業<a hidden class=anchor aria-hidden=true href=#前置作業>#</a></h3><p>首先創建一包資料夾、產生 package.json 並安裝 webpack、webpack-cli 及 lodash （lodash 是為了測試 code splitting 用的第三方套件）PS: Npm 6.4, Webpack 4.29</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir codesplitting
</span></span><span style=display:flex><span>cd codesplitting
</span></span><span style=display:flex><span>npm init -y
</span></span><span style=display:flex><span>npm i webpack webpack-cli lodash
</span></span></code></pre></div><h3 id=第一式mutiple-entry>第一式：Mutiple Entry<a hidden class=anchor aria-hidden=true href=#第一式mutiple-entry>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>path</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;path&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>entry</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>page1</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;./src/page1.js&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>page2</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;./src/page2.js&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mode</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;development&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>output</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>path</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>__dirname</span>, <span style=color:#e6db74>&#34;dist&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;[name].bundle.js&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>新增 <code>src/page1.js</code>，並輸入</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;this is page1&#34;</span>);
</span></span></code></pre></div><p>新增 <code>src/page2.js</code>，並輸入</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;this is page2&#34;</span>);
</span></span></code></pre></div><p>接著在 command line 執行 <code>npx webpack</code> 就可以看到專案下多了一個 <code>dist</code> 資料夾，裡面放著打包好的檔案 <code>page1.bundle.js && page2.bundle.js</code></p><p>將它門打開來看可能發現一堆看不懂的 code，不過分別搜尋 <code>console.log('this is page1') && console.log('this is page2')</code> 確實包含在裡面。</p><p>OK！這樣已經完成最初階的 CodeSplitting，我們可以透過前端 route 的手法讓使用者者切到 <code>/page1</code> 的時候載入 <code>page1.bundle.js</code> 就好， <code>/page2</code> 則是 <code>page2.bundle.js</code></p><p>那如果讓 page1、2 一起使用 <code>lodash</code> 會發生什麼事？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// /src/page1.js
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>lodash</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;lodash&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;this is page1&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// /src/page2.js
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>lodash</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;lodash&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;this is page2&#34;</span>);
</span></span></code></pre></div><p>一樣使用 npx webpack 指令後會發現 page1、2.bundle.js 都變成一樣肥。</p><p>為了方便驗證，我們來使用 webpack-bundle-analyzer plugin。</p><ol><li>npm install — save-dev webpack-bundle-analyzer</li><li>webpack.config.js 改成</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>path</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;path&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>BundleAnalyzerPlugin</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;webpack-bundle-analyzer&#34;</span>).<span style=color:#a6e22e>BundleAnalyzerPlugin</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>entry</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>page1</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;./src/page1.js&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>page2</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;./src/page2.js&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mode</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;development&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>output</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>path</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>__dirname</span>, <span style=color:#e6db74>&#34;dist&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;[name].bundle.js&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>BundleAnalyzerPlugin</span>()],
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>再執行一次 npx webpack 時，可以在 http://127.0.0.1:8888 看到它分析的結果</p><p><img loading=lazy src=/posts/webpack-split-chunk/not_split_lodash_chunk.jpg alt=loadsh-chunk></p><p>這樣是非常不合理，應該把 lodash.js 獨立成另外一個檔案（chunk)，讓 page1、2 共同使用</p><h3 id=第二式splitchunksplugin>第二式：SplitChunksPlugin<a hidden class=anchor aria-hidden=true href=#第二式splitchunksplugin>#</a></h3><p>為了避免同樣的 module 被重複打包，可以使用 webpack 提供的套件 SplitChunksPlugin，原本叫做 CommonsChunkPlugin，但在後來的版本被納入內建使用，只要在 <code>optimization.splitChunks</code> 設定即可</p><p>修改一下 webpack.config.js</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>path</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;path&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>BundleAnalyzerPlugin</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;webpack-bundle-analyzer&#34;</span>).<span style=color:#a6e22e>BundleAnalyzerPlugin</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>entry</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>page1</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;./src/page1.js&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>page2</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;./src/page2.js&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mode</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;development&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>output</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>path</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>__dirname</span>, <span style=color:#e6db74>&#34;dist&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;[name].bundle.js&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>optimization</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>splitChunks</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>chunks</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;all&#34;</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>BundleAnalyzerPlugin</span>()],
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>輸入 npx webpack</p><p><img loading=lazy src=/posts/webpack-split-chunk/has_split_lodash_chunk.jpg alt=loadsh-chunk></p><p>可以看到 lodash 被獨立成單獨的檔案</p><p>~Async chunks VS Non-async chunks~</p><p>如果將 <code>chunks: 'all'</code> 改成 <code>chunks: 'async'</code> 再執行 <code>npx webpack</code> ，會發現結果又回到原本的樣子，為什麼呢？</p><p>因為使用 mutiple entry 載入的檔案會被歸類為 Non-async chunk，設定 <code>chunk:'async'</code> 後，SplitChunksPlugin 只會對 Async chunk 進行 Code-Splitting 的優化</p><p>那麼怎樣算是 Async chunk 呢？</p><h3 id=第三式dynamic-imports>第三式：Dynamic Imports<a hidden class=anchor aria-hidden=true href=#第三式dynamic-imports>#</a></h3><p>只要使用 <code>import(...)</code> 載入的檔案，webpack 會自動將它打包成一個獨立檔案，同時也被視為 Async chunk</p><p>它跟 mutiple entry 有相同的效果，但是卻可以在一個檔案內用 dynamic 方式 import 多個檔案，我們來修改範例</p><p>在 src/ 底下新增 index.js 檔案</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>import</span>(<span style=color:#e6db74>&#34;./page1.js&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span>(<span style=color:#e6db74>&#34;./page2.js&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;this is index.js&#34;</span>);
</span></span></code></pre></div><p>修改 webpack.config.js</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>entry</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;./src/index.js&#34;</span>;
</span></span></code></pre></div><p>執行 npx webpack</p><p><img loading=lazy src=/posts/webpack-split-chunk/console_output_chunk_result.jpg alt=loadsh-chunk></p><p><img loading=lazy src=/posts/webpack-split-chunk/has_split_chunk_all.jpg alt=loadsh-chunk></p><p>可以看到 page1、2 都被個別獨立成一個檔案，而且他們之間共用的套件（lodash) 也被獨立成例外一個檔名。</p><h3 id=如何使用-react-簡單辦到>如何使用 React 簡單辦到<a hidden class=anchor aria-hidden=true href=#如何使用-react-簡單辦到>#</a></h3><p>這裡貼上 React 文件上 Route 與 Code Splitting 的範例</p><p><img loading=lazy src=/posts/webpack-split-chunk/react_code_split_sample.jpg alt=loadsh-chunk></p><p>簡單地來說，所有 component 都使用 import(&mldr;) 載入並掛上 Route 物件，這樣一來就可以根據不同頁面載入其所需的資源（ js 檔案）</p><h3 id=總結>總結<a hidden class=anchor aria-hidden=true href=#總結>#</a></h3><p>讀完以上簡介後可以發現設定 webpack code-splitting 並不難，只要簡單幾步就可以很有效的優化專案載入效能</p><p>然而 SplitChunks 裡面也有其他設定可以讓你將檔案切的更碎，此時就需評估是否有這個必要，會不會造成過多的 loading 反而影響了使用者體驗？</p><p>Reference</p><p><a href=https://reactjs.org/docs/code-splitting.html>Code-Splitting - React</a>
<a href=https://medium.com/dailyjs/webpack-4-splitchunks-plugin-d9fbbe091fd0>Webpack 4 — Mysterious SplitChunks Plugin</a>
<a href=https://webpack.js.org/plugins/split-chunks-plugin/>SplitChunksPlugin | webpack</a>
<a href=https://webpack.js.org/guides/code-splitting/>Code Splitting | webpack</a></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://curt6815463.github.io/hakka-dev-blog/>Hakka Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>